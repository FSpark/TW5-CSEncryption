{"title":"$:/plugins/FSpark/TW5-CSE","name":"TW5-CSEncryption","description":"Client-Side Encryption for TiddlyWiki5 on Node.js","author":"FSpark","version":"0.5.0","core-version":"5.3.3","source":"","list":"readme ui/SettingsPanel license","parent-plugin":"","dependents":"$:/plugins/tiddlywiki/tiddlyweb","plugin-type":"plugin","packaged-by":"Gatha on 25th April 2023, 21:08:50","released":"2024-10-21T14:50:10.194Z","type":"application/json","text":"{\"tiddlers\":{\"$:/plugins/FSpark/TW5-CSE/action-cse-forcepush.js\":{\"title\":\"$:/plugins/FSpark/TW5-CSE/action-cse-forcepush.js\",\"text\":\"/*\\\\\\ntitle: $:/plugins/FSpark/TW5-CSE/action-cse-forcepush.js\\nmodule-type: widget\\ntype: application/javascript\\n\\\\*/\\n\\n\\\"use strict\\\";\\n\\n(function () {\\n  /*jslint node: true, browser: true */\\n  /*global $tw: false */\\n  \\\"use strict\\\";\\n\\n  var Widget = require(\\\"$:/core/modules/widgets/widget.js\\\").widget;\\n  var ForcePushWidget = function ForcePushWidget(parseTreeNode, options) {\\n    this.initialise(parseTreeNode, options);\\n  };\\n\\n  /*\\n  Inherit from the base widget class\\n  */\\n  ForcePushWidget.prototype = new Widget();\\n\\n  /*\\n  Render this widget into the DOM\\n  */\\n  ForcePushWidget.prototype.render = function (parent, nextSibling) {\\n    this.computeAttributes();\\n    this.execute();\\n  };\\n\\n  /*\\n  Compute the internal state of the widget\\n  */\\n  ForcePushWidget.prototype.execute = function () {\\n    this.actionFilter = this.getAttribute(\\\"$filter\\\");\\n  };\\n\\n  /*\\n  Refresh the widget by ensuring our attributes are up to date\\n  */\\n  ForcePushWidget.prototype.refresh = function (changedTiddlers) {\\n    var changedAttributes = this.computeAttributes();\\n    if (changedAttributes[\\\"$filter\\\"]) {\\n      this.refreshSelf();\\n      return true;\\n    }\\n    return this.refreshChildren(changedTiddlers);\\n  };\\n\\n  /*\\n  Invoke the action associated with this widget\\n  */\\n  ForcePushWidget.prototype.invokeAction = function (triggeringWidget, event) {\\n    if (this.actionFilter) {\\n      $tw.CSE.forcePush(this.actionFilter, this);\\n    }\\n    return true; // Action was invoked\\n  };\\n\\n  exports[\\\"action-cse-forcepush\\\"] = ForcePushWidget;\\n})();\\n\",\"module-type\":\"widget\",\"type\":\"application/javascript\"},\"$:/plugins/FSpark/TW5-CSE/boot/cseBootTemplate.tid\":{\"title\":\"$:/plugins/FSpark/TW5-CSE/boot/cseBootTemplate.tid\",\"text\":\"<$set name=\\\"saveTiddlerAndShadowsFilter\\\" filter=\\\"[subfilter<saveTiddlerFilter>] [subfilter<saveTiddlerFilter>plugintiddlers[]]\\\">\\n`<!doctype html>\\n`{{$:/core/templates/MOTW.html}}`<html lang=\\\"`<$text text={{{ [{$:/language}get[name]] }}}/>`\\\">\\n<head>\\n<meta http-equiv=\\\"Content-Type\\\" content=\\\"text/html;charset=utf-8\\\" />\\n<!--~~ Raw markup for the top of the head section ~~-->\\n`{{{ [enlist<saveTiddlerAndShadowsFilter>tag[$:/tags/RawMarkupWikified/TopHead]] ||$:/core/templates/raw-static-tiddler}}}`\\n<meta http-equiv=\\\"X-UA-Compatible\\\" content=\\\"IE=Edge\\\"/>\\n<meta name=\\\"application-name\\\" content=\\\"TiddlyWiki\\\" />\\n<meta name=\\\"generator\\\" content=\\\"TiddlyWiki\\\" />\\n<meta name=\\\"tiddlywiki-version\\\" content=\\\"`{{$:/core/templates/version}}`\\\" />\\n<meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1.0\\\" />\\n<meta name=\\\"apple-mobile-web-app-capable\\\" content=\\\"yes\\\" />\\n<meta name=\\\"apple-mobile-web-app-status-bar-style\\\" content=\\\"black-translucent\\\" />\\n<meta name=\\\"mobile-web-app-capable\\\" content=\\\"yes\\\"/>\\n<meta name=\\\"format-detection\\\" content=\\\"telephone=no\\\" />\\n<meta name=\\\"copyright\\\" content=\\\"`{{$:/core/copyright.txt}}`\\\" />\\n<link id=\\\"faviconLink\\\" rel=\\\"shortcut icon\\\" href=\\\"favicon.ico\\\">\\n<title>`{{$:/core/wiki/title}}`</title>\\n<!--~~ This is a Tiddlywiki file. The points of interest in the file are marked with this pattern ~~-->\\n\\n<!--~~ Raw markup ~~-->\\n`{{{ [enlist<saveTiddlerAndShadowsFilter>tag[$:/core/wiki/rawmarkup]] ||$:/core/templates/plain-text-tiddler}}}\\n{{{ [enlist<saveTiddlerAndShadowsFilter>tag[$:/tags/RawMarkup]] ||$:/core/templates/plain-text-tiddler}}}\\n{{{ [enlist<saveTiddlerAndShadowsFilter>tag[$:/tags/RawMarkupWikified]] ||$:/core/templates/raw-static-tiddler}}}`\\n</head>\\n<body class=\\\"tc-body\\\">\\n<!--~~ Raw markup for the top of the body section ~~-->\\n`{{{ [enlist<saveTiddlerAndShadowsFilter>tag[$:/tags/RawMarkupWikified/TopBody]] ||$:/core/templates/raw-static-tiddler}}}`\\n<!--~~ Static styles ~~-->\\n<div id=\\\"styleArea\\\">\\n`{{$:/boot/boot.css||$:/core/templates/css-tiddler}}`\\n</div>\\n<!--~~ Static content for Google and browsers without JavaScript ~~-->\\n<noscript>\\n<div id=\\\"splashArea\\\">\\n`{{$:/core/templates/static.area}}`\\n</div>\\n</noscript>\\n<!--~~ Ordinary tiddlers ~~-->\\n`{{$:/core/templates/store.area.template.html}}`\\n<!--~~ Library modules ~~-->\\n<div id=\\\"libraryModules\\\" style=\\\"display:none;\\\">\\n`{{{ [is[system]type[application/javascript]library[yes]] ||$:/core/templates/javascript-tiddler}}}`\\n</div>\\n<!--~~ Boot kernel prologue ~~-->\\n<div id=\\\"bootKernelPrefix\\\" style=\\\"display:none;\\\">\\n`{{ $:/boot/bootprefix.js ||$:/core/templates/javascript-tiddler}}`\\n</div>\\n<!--~~ Boot kernel ~~-->\\n<div id=\\\"bootKernel\\\" style=\\\"display:none;\\\">\\n<script data-tiddler-title=\\\"$:/boot/boot.js\\\" data-tiddler-type=\\\"application/javascript\\\" type=\\\"text/javascript\\\">\\n`<$transclude tiddler=\\\"$:/plugins/FSpark/TW5-CSE\\\" subtiddler=\\\"$:/boot/boot.js\\\"/>`\\n</script>\\n</div>\\n<!--~~ Raw markup for the bottom of the body section ~~-->\\n`{{{ [enlist<saveTiddlerAndShadowsFilter>tag[$:/tags/RawMarkupWikified/BottomBody]] ||$:/core/templates/raw-static-tiddler}}}`\\n</body>\\n</html>`\\n\"},\"$:/plugins/FSpark/TW5-CSE/boot/entry.tid\":{\"title\":\"$:/plugins/FSpark/TW5-CSE/boot/entry.tid\",\"text\":\"\\\\import [[$:/core/ui/PageMacros]] [all[shadows+tiddlers]tag[$:/tags/Macro]!has[draft.of]]\\n\\\\define saveTiddlerFilter()\\n[is[tiddler]] -[prefix[$:/state/popup/]] -[prefix[$:/temp/]] -[prefix[$:/HistoryList]] -[status[pending]plugin-type[import]] -[[$:/boot/boot.css]] -[type[application/javascript]library[yes]] -[[$:/boot/boot.js]] -[[$:/boot/bootprefix.js]] +[sort[title]] $(publishFilter)$\\n\\\\end\\n{{$:/plugins/FSpark/TW5-CSE/boot/cseBootTemplate.tid}}\"},\"$:/config/TW5-CSE/EncryptFilter\":{\"title\":\"$:/config/TW5-CSE/EncryptFilter\",\"type\":\"text/vnd.tiddlywiki\",\"text\":\"[all[]!is[system]!is[binary]]\"},\"$:/plugins/FSpark/TW5-CSE/metaconfig.json\":{\"text\":\"{\\n    \\\"RmbPwd\\\": \\\"no\\\"\\n}\",\"type\":\"application/json\",\"title\":\"$:/plugins/FSpark/TW5-CSE/metaconfig.json\"},\"$:/plugins/FSpark/TW5-CSE/csemeta.js\":{\"title\":\"$:/plugins/FSpark/TW5-CSE/csemeta.js\",\"text\":\"/*\\\\\\nmodule-type: macro\\ntitle: $:/plugins/FSpark/TW5-CSE/csemeta.js\\ntype: application/javascript\\n\\\\*/\\n\\n\\\"use strict\\\";\\n\\n(function () {\\n  /*jslint node: true, browser: true */\\n  /*global $tw: false */\\n  \\\"use strict\\\";\\n\\n  /*\\n  Information about this macro\\n  */\\n  exports.name = \\\"csemeta\\\";\\n  exports.params = [];\\n\\n  /*\\n  Run the macro\\n  */\\n  exports.run = function () {\\n    return JSON.stringify({\\n      version: $tw.wiki.getTextReference(\\\"$:/plugins/FSpark/TW5-CSE!!version\\\", \\\"0.0.0\\\"),\\n      lastCoreVersion: $tw.version,\\n      config: $tw.wiki.getTiddlerData(\\\"$:/plugins/FSpark/TW5-CSE/metaconfig.json\\\")\\n    });\\n  };\\n})();\\n\",\"module-type\":\"macro\",\"type\":\"application/javascript\"},\"$:/plugins/FSpark/TW5-CSE/license\":{\"title\":\"$:/plugins/FSpark/TW5-CSE/license\",\"type\":\"text/plain\",\"text\":\"MIT License\\n\\nCopyright (c) 2023 FSpark\\n\\nPermission is hereby granted, free of charge, to any person obtaining a copy\\nof this software and associated documentation files (the \\\"Software\\\"), to deal\\nin the Software without restriction, including without limitation the rights\\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\ncopies of the Software, and to permit persons to whom the Software is\\nfurnished to do so, subject to the following conditions:\\n\\nThe above copyright notice and this permission notice shall be included in all\\ncopies or substantial portions of the Software.\\n\\nTHE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\\nSOFTWARE.\"},\"$:/plugins/FSpark/TW5-CSE/readme\":{\"title\":\"$:/plugins/FSpark/TW5-CSE/readme\",\"type\":\"text/vnd.tiddlywiki\",\"text\":\"<div align=\\\"center\\\">\\n\\n! TW5-CSEncryption\\n\\nClient-Side Encryption for [[TiddlyWiki5|https://tiddlywiki.com]] on Node.js\\n</div>\\n\\n!!! Check CSE\\n\\nPlease go $:/plugins/FSpark/TW5-CSE/settings/check first to check if CSE started successfully.\\n\\n!!! Getting Started\\nYou can see the {{$:/plugins/FSpark/TW5-CSE/ui/cloudunlock}} button in the sidebar, this is the unencrypted state, at this point the written Tiddlers are all in sync as normal.\\n\\nIn the unencrypted state, you can manually override the filters under $:/config/TW5-CSE/EncryptFilter directly first, and this setting will be applied automatically the next time you encrypt. However, if you are in encrypted state, it is better to perform filter migration via $:/plugins/FSpark/TW5-CSE/settings/filter .\\n\\n!!! Start Encryption\\n\\nWrite something random and click the {{$:/plugins/FSpark/TW5-CSE/ui/cloudlock}} button. Enter the password in the dialog and wait for it to sync.\\n\\nAfter that, click the {{$:/plugins/FSpark/TW5-CSE/ui/cloudlock}} button again and you will be taken to the plugin's settings page: $:/plugins/FSpark/TW5-CSE/ui/SettingsPanel, where you can change the password or something like that.\\n\\n!!! Further More\\n* Online documentation: https://fspark.github.io/TW5-CSEncryption/\\n* Issue feedback: https://github.com/FSpark/TW5-CSEncryption/issues\"},\"$:/plugins/FSpark/TW5-CSE/filters/decrement\":{\"title\":\"$:/plugins/FSpark/TW5-CSE/filters/decrement\",\"caption\":\"Will be decrypted\",\"type\":\"text/vnd.tiddlywiki\",\"text\":\"[subfilter<oldfilter>] -[subfilter<newfilter>]\"},\"$:/plugins/FSpark/TW5-CSE/filters/increment\":{\"title\":\"$:/plugins/FSpark/TW5-CSE/filters/increment\",\"caption\":\"Addition to be encrypted\",\"type\":\"text/vnd.tiddlywiki\",\"text\":\"[subfilter<newfilter>] -[subfilter<oldfilter>]\"},\"$:/plugins/FSpark/TW5-CSE/filters/union\":{\"title\":\"$:/plugins/FSpark/TW5-CSE/filters/union\",\"caption\":\"Changes will be pushed to the server\",\"type\":\"text/vnd.tiddlywiki\",\"vars\":\"decrement={{$:/plugins/FSpark/TW5-CSE/filters/decrement}} increment={{$:/plugins/FSpark/TW5-CSE/filters/increment}}\",\"text\":\"[subfilter<decrement>] [subfilter<increment>]\"},\"$:/plugins/FSpark/TW5-CSE/icon\":{\"title\":\"$:/plugins/FSpark/TW5-CSE/icon\",\"type\":\"text/vnd.tiddlywiki\",\"text\":\"{{$:/plugins/FSpark/TW5-CSE/ui/cloudlock}}\"},\"$:/plugins/FSpark/TW5-CSE/invoke.js\":{\"title\":\"$:/plugins/FSpark/TW5-CSE/invoke.js\",\"text\":\"/*\\\\\\nmodule-type: macro\\ntitle: $:/plugins/FSpark/TW5-CSE/invoke.js\\ntype: application/javascript\\n\\\\*/\\n\\n\\\"use strict\\\";\\n\\n(function () {\\n  /*jslint node: true, browser: true */\\n  /*global $tw: false */\\n  \\\"use strict\\\";\\n\\n  /*\\n  Invoke Action String By buggyj\\n  https://talk.tiddlywiki.org/t/is-it-possible-to-execute-an-action-widget-on-tiddler-load-render-open/3085/2\\n  */\\n  exports.name = \\\"invoke\\\";\\n  exports.params = [{\\n    name: \\\"action\\\"\\n  }];\\n\\n  /*\\n  Run the macro\\n  */\\n  exports.run = function (action) {\\n    // debugger;\\n    this.invokeActionString(action, this, {}, {});\\n    return \\\"\\\";\\n  };\\n})();\\n\",\"module-type\":\"macro\",\"type\":\"application/javascript\"},\"$:/boot/boot.js\":{\"title\":\"$:/boot/boot.js\",\"text\":\"/*\\\\\\ntitle: $:/boot/boot.js\\ntype: application/javascript\\n\\nThe main boot kernel for TiddlyWiki. This single file creates a barebones TW environment that is just sufficient to bootstrap the modules containing the main logic of the application.\\n\\nOn the server this file is executed directly to boot TiddlyWiki. In the browser, this file is packed into a single HTML file.\\n\\n\\\\*/\\n\\nvar _boot = (function($tw) {\\n\\n\\t/*jslint node: true, browser: true */\\n\\t/*global modules: false, $tw: false */\\n\\t\\\"use strict\\\";\\n\\t\\n\\t// Include bootprefix if we're not given module data\\n\\tif(!$tw) {\\n\\t\\t$tw = require(\\\"./bootprefix.js\\\").bootprefix();\\n\\t}\\n\\t\\n\\t$tw.utils = $tw.utils || Object.create(null);\\n\\t\\n\\t/////////////////////////// Standard node.js libraries\\n\\t\\n\\tvar fs, path, vm;\\n\\tif($tw.node) {\\n\\t\\tfs = require(\\\"fs\\\");\\n\\t\\tpath = require(\\\"path\\\");\\n\\t\\tvm = require(\\\"vm\\\");\\n\\t}\\n\\t\\n\\t/////////////////////////// Utility functions\\n\\t\\n\\t$tw.boot.log = function(str) {\\n\\t\\t$tw.boot.logMessages = $tw.boot.logMessages || [];\\n\\t\\t$tw.boot.logMessages.push(str);\\n\\t}\\n\\t\\n\\t/*\\n\\tCheck if an object has a property\\n\\t*/\\n\\t$tw.utils.hop = function(object,property) {\\n\\t\\treturn object ? Object.prototype.hasOwnProperty.call(object,property) : false;\\n\\t};\\n\\t\\n\\t/*\\n\\tDetermine if a value is an array\\n\\t*/\\n\\t$tw.utils.isArray = function(value) {\\n\\t\\treturn Object.prototype.toString.call(value) == \\\"[object Array]\\\";\\n\\t};\\n\\t\\n\\t/*\\n\\tCheck if an array is equal by value and by reference.\\n\\t*/\\n\\t$tw.utils.isArrayEqual = function(array1,array2) {\\n\\t\\tif(array1 === array2) {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\tarray1 = array1 || [];\\n\\t\\tarray2 = array2 || [];\\n\\t\\tif(array1.length !== array2.length) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\treturn array1.every(function(value,index) {\\n\\t\\t\\treturn value === array2[index];\\n\\t\\t});\\n\\t};\\n\\t\\n\\t/*\\n\\tAdd an entry to a sorted array if it doesn't already exist, while maintaining the sort order\\n\\t*/\\n\\t$tw.utils.insertSortedArray = function(array,value) {\\n\\t\\tvar low = 0, high = array.length - 1, mid, cmp;\\n\\t\\twhile(low <= high) {\\n\\t\\t\\tmid = (low + high) >> 1;\\n\\t\\t\\tcmp = value.localeCompare(array[mid]);\\n\\t\\t\\tif(cmp > 0) {\\n\\t\\t\\t\\tlow = mid + 1;\\n\\t\\t\\t} else if(cmp < 0) {\\n\\t\\t\\t\\thigh = mid - 1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn array;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tarray.splice(low,0,value);\\n\\t\\treturn array;\\n\\t};\\n\\t\\n\\t/*\\n\\tPush entries onto an array, removing them first if they already exist in the array\\n\\t\\tarray: array to modify (assumed to be free of duplicates)\\n\\t\\tvalue: a single value to push or an array of values to push\\n\\t*/\\n\\t$tw.utils.pushTop = function(array,value) {\\n\\t\\tvar t,p;\\n\\t\\tif($tw.utils.isArray(value)) {\\n\\t\\t\\t// Remove any array entries that are duplicated in the new values\\n\\t\\t\\tif(value.length !== 0) {\\n\\t\\t\\t\\tif(array.length !== 0) {\\n\\t\\t\\t\\t\\tif(value.length < array.length) {\\n\\t\\t\\t\\t\\t\\tfor(t=0; t<value.length; t++) {\\n\\t\\t\\t\\t\\t\\t\\tp = array.indexOf(value[t]);\\n\\t\\t\\t\\t\\t\\t\\tif(p !== -1) {\\n\\t\\t\\t\\t\\t\\t\\t\\tarray.splice(p,1);\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tfor(t=array.length-1; t>=0; t--) {\\n\\t\\t\\t\\t\\t\\t\\tp = value.indexOf(array[t]);\\n\\t\\t\\t\\t\\t\\t\\tif(p !== -1) {\\n\\t\\t\\t\\t\\t\\t\\t\\tarray.splice(t,1);\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// Push the values on top of the main array\\n\\t\\t\\t\\tarray.push.apply(array,value);\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tp = array.indexOf(value);\\n\\t\\t\\tif(p !== -1) {\\n\\t\\t\\t\\tarray.splice(p,1);\\n\\t\\t\\t}\\n\\t\\t\\tarray.push(value);\\n\\t\\t}\\n\\t\\treturn array;\\n\\t};\\n\\t\\n\\t/*\\n\\tDetermine if a value is a date\\n\\t*/\\n\\t$tw.utils.isDate = function(value) {\\n\\t\\treturn Object.prototype.toString.call(value) === \\\"[object Date]\\\";\\n\\t};\\n\\t\\n\\t/*\\n\\tIterate through all the own properties of an object or array. Callback is invoked with (element,title,object)\\n\\t*/\\n\\t$tw.utils.each = function(object,callback) {\\n\\t\\tvar next,f,length;\\n\\t\\tif(object) {\\n\\t\\t\\tif(Object.prototype.toString.call(object) == \\\"[object Array]\\\") {\\n\\t\\t\\t\\tfor(f=0, length=object.length; f<length; f++) {\\n\\t\\t\\t\\t\\tnext = callback(object[f],f,object);\\n\\t\\t\\t\\t\\tif(next === false) {\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tvar keys = Object.keys(object);\\n\\t\\t\\t\\tfor(f=0, length=keys.length; f<length; f++) {\\n\\t\\t\\t\\t\\tvar key = keys[f];\\n\\t\\t\\t\\t\\tnext = callback(object[key],key,object);\\n\\t\\t\\t\\t\\tif(next === false) {\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\t\\n\\t/*\\n\\tHelper for making DOM elements\\n\\ttag: tag name\\n\\toptions: see below\\n\\tOptions include:\\n\\tnamespace: defaults to http://www.w3.org/1999/xhtml\\n\\tattributes: hashmap of attribute values\\n\\tstyle: hashmap of styles\\n\\ttext: text to add as a child node\\n\\tchildren: array of further child nodes\\n\\tinnerHTML: optional HTML for element\\n\\tclass: class name(s)\\n\\tdocument: defaults to current document\\n\\teventListeners: array of event listeners (this option won't work until $tw.utils.addEventListeners() has been loaded)\\n\\t*/\\n\\t$tw.utils.domMaker = function(tag,options) {\\n\\t\\tvar options = options || {};\\n\\t\\tvar doc = options.document || document;\\n\\t\\tvar element = doc.createElementNS(options.namespace || \\\"http://www.w3.org/1999/xhtml\\\",tag);\\n\\t\\tif(options[\\\"class\\\"]) {\\n\\t\\t\\telement.className = options[\\\"class\\\"];\\n\\t\\t}\\n\\t\\tif(options.text) {\\n\\t\\t\\telement.appendChild(doc.createTextNode(options.text));\\n\\t\\t}\\n\\t\\t$tw.utils.each(options.children,function(child) {\\n\\t\\t\\telement.appendChild(child);\\n\\t\\t});\\n\\t\\tif(options.innerHTML) {\\n\\t\\t\\telement.innerHTML = options.innerHTML;\\n\\t\\t}\\n\\t\\t$tw.utils.each(options.attributes,function(attribute,name) {\\n\\t\\t\\telement.setAttribute(name,attribute);\\n\\t\\t});\\n\\t\\t$tw.utils.each(options.style,function(value,name) {\\n\\t\\t\\telement.style[name] = value;\\n\\t\\t});\\n\\t\\tif(options.eventListeners) {\\n\\t\\t\\t$tw.utils.addEventListeners(element,options.eventListeners);\\n\\t\\t}\\n\\t\\treturn element;\\n\\t};\\n\\t\\n\\t/*\\n\\tDisplay an error and exit\\n\\t*/\\n\\t$tw.utils.error = function(err) {\\n\\t\\t// Prepare the error message\\n\\t\\tvar errHeading = ( $tw.language == undefined ? \\\"Internal JavaScript Error\\\" : $tw.language.getString(\\\"InternalJavaScriptError/Title\\\") ),\\n\\t\\t\\tpromptMsg = ( $tw.language == undefined ? \\\"Well, this is embarrassing. It is recommended that you restart TiddlyWiki by refreshing your browser\\\" : $tw.language.getString(\\\"InternalJavaScriptError/Hint\\\") );\\n\\t\\t// Log the error to the console\\n\\t\\tconsole.error($tw.node ? \\\"\\\\x1b[1;31m\\\" + err + \\\"\\\\x1b[0m\\\" : err);\\n\\t\\tif($tw.browser && !$tw.node) {\\n\\t\\t\\t// Display an error message to the user\\n\\t\\t\\tvar dm = $tw.utils.domMaker,\\n\\t\\t\\t\\theading = dm(\\\"h1\\\",{text: errHeading}),\\n\\t\\t\\t\\tprompt = dm(\\\"div\\\",{text: promptMsg, \\\"class\\\": \\\"tc-error-prompt\\\"}),\\n\\t\\t\\t\\tmessage = dm(\\\"div\\\",{text: err, \\\"class\\\":\\\"tc-error-message\\\"}),\\n\\t\\t\\t\\tcloseButton = dm(\\\"div\\\",{children: [dm(\\\"button\\\",{text: ( $tw.language == undefined ? \\\"close\\\" : $tw.language.getString(\\\"Buttons/Close/Caption\\\") )})], \\\"class\\\": \\\"tc-error-prompt\\\"}),\\n\\t\\t\\t\\tdownloadButton = dm(\\\"div\\\",{children: [dm(\\\"button\\\",{text: ( $tw.language == undefined ? \\\"download tiddlers\\\" : $tw.language.getString(\\\"Buttons/EmergencyDownload/Caption\\\") )})], \\\"class\\\": \\\"tc-error-prompt\\\"}),\\n\\t\\t\\t\\tform = dm(\\\"form\\\",{children: [heading,prompt,downloadButton,message,closeButton], \\\"class\\\": \\\"tc-error-form\\\"});\\n\\t\\t\\tdocument.body.insertBefore(form,document.body.firstChild);\\n\\t\\t\\tdownloadButton.addEventListener(\\\"click\\\",function(event) {\\n\\t\\t\\t\\tif($tw && $tw.wiki) {\\n\\t\\t\\t\\t\\tvar tiddlers = [];\\n\\t\\t\\t\\t\\t$tw.wiki.each(function(tiddler,title) {\\n\\t\\t\\t\\t\\t\\ttiddlers.push(tiddler.fields);\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t\\tvar link = dm(\\\"a\\\"),\\n\\t\\t\\t\\t\\t\\ttext = JSON.stringify(tiddlers);\\n\\t\\t\\t\\t\\tif(Blob !== undefined) {\\n\\t\\t\\t\\t\\t\\tvar blob = new Blob([text], {type: \\\"text/html\\\"});\\n\\t\\t\\t\\t\\t\\tlink.setAttribute(\\\"href\\\", URL.createObjectURL(blob));\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tlink.setAttribute(\\\"href\\\",\\\"data:text/html,\\\" + encodeURIComponent(text));\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tlink.setAttribute(\\\"download\\\",\\\"emergency-tiddlers-\\\" + (new Date()) + \\\".json\\\");\\n\\t\\t\\t\\t\\tdocument.body.appendChild(link);\\n\\t\\t\\t\\t\\tlink.click();\\n\\t\\t\\t\\t\\tdocument.body.removeChild(link);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\talert(\\\"Emergency tiddler download is not available\\\");\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tevent.preventDefault();\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t},true);\\n\\t\\t\\tform.addEventListener(\\\"submit\\\",function(event) {\\n\\t\\t\\t\\tdocument.body.removeChild(form);\\n\\t\\t\\t\\tevent.preventDefault();\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t},true);\\n\\t\\t\\treturn null;\\n\\t\\t} else if(!$tw.browser) {\\n\\t\\t\\t// Exit if we're under node.js\\n\\t\\t\\tprocess.exit(1);\\n\\t\\t}\\n\\t};\\n\\t\\n\\t/*\\n\\tUse our custom error handler if we're in the browser\\n\\t*/\\n\\tif($tw.boot.tasks.trapErrors) {\\n\\t\\twindow.onerror = function(errorMsg,url,lineNumber) {\\n\\t\\t\\t$tw.utils.error(errorMsg);\\n\\t\\t\\treturn false;\\n\\t\\t};\\n\\t}\\n\\t\\n\\t/*\\n\\tExtend an object with the properties from a list of source objects\\n\\t*/\\n\\t$tw.utils.extend = function(object /*, sourceObjectList */) {\\n\\t\\t$tw.utils.each(Array.prototype.slice.call(arguments,1),function(source) {\\n\\t\\t\\tif(source) {\\n\\t\\t\\t\\tfor(var p in source) {\\n\\t\\t\\t\\t\\tobject[p] = source[p];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t});\\n\\t\\treturn object;\\n\\t};\\n\\t\\n\\t/*\\n\\tFill in any null or undefined properties of an object with the properties from a list of source objects. Each property that is an object is called recursively\\n\\t*/\\n\\t$tw.utils.deepDefaults = function(object /*, sourceObjectList */) {\\n\\t\\t$tw.utils.each(Array.prototype.slice.call(arguments,1),function(source) {\\n\\t\\t\\tif(source) {\\n\\t\\t\\t\\tfor(var p in source) {\\n\\t\\t\\t\\t\\tif(object[p] === null || object[p] === undefined) {\\n\\t\\t\\t\\t\\t\\tobject[p] = source[p];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(typeof object[p] === \\\"object\\\" && typeof source[p] === \\\"object\\\") {\\n\\t\\t\\t\\t\\t\\t$tw.utils.deepDefaults(object[p],source[p]);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t});\\n\\t\\treturn object;\\n\\t};\\n\\t\\n\\t/*\\n\\tConvert a URIComponent encoded string to a string safely\\n\\t*/\\n\\t$tw.utils.decodeURIComponentSafe = function(s) {\\n\\t\\tvar v = s;\\n\\t\\ttry {\\n\\t\\t\\tv = decodeURIComponent(s);\\n\\t\\t} catch(e) {}\\n\\t\\treturn v;\\n\\t};\\n\\t\\n\\t/*\\n\\tConvert a URI encoded string to a string safely\\n\\t*/\\n\\t$tw.utils.decodeURISafe = function(s) {\\n\\t\\tvar v = s;\\n\\t\\ttry {\\n\\t\\t\\tv = decodeURI(s);\\n\\t\\t} catch(e) {}\\n\\t\\treturn v;\\n\\t};\\n\\t\\n\\t/*\\n\\tConvert \\\"&amp;\\\" to &, \\\"&nbsp;\\\" to nbsp, \\\"&lt;\\\" to <, \\\"&gt;\\\" to > and \\\"&quot;\\\" to \\\"\\n\\t*/\\n\\t$tw.utils.htmlDecode = function(s) {\\n\\t\\treturn s.toString().replace(/&lt;/mg,\\\"<\\\").replace(/&nbsp;/mg,\\\"\\\\xA0\\\").replace(/&gt;/mg,\\\">\\\").replace(/&quot;/mg,\\\"\\\\\\\"\\\").replace(/&amp;/mg,\\\"&\\\");\\n\\t};\\n\\t\\n\\t/*\\n\\tGet the browser location.hash. We don't use location.hash because of the way that Firefox auto-urldecodes it (see http://stackoverflow.com/questions/1703552/encoding-of-window-location-hash)\\n\\t*/\\n\\t$tw.utils.getLocationHash = function() {\\n\\t\\tvar href = window.location.href;\\n\\t\\tvar idx = href.indexOf('#');\\n\\t\\tif(idx === -1) {\\n\\t\\t\\treturn \\\"#\\\";\\n\\t\\t} else if(href.substr(idx + 1,1) === \\\"#\\\" ||  href.substr(idx + 1,3) === \\\"%23\\\") {\\n\\t\\t\\t// Special case: ignore location hash if it itself starts with a #\\n\\t\\t\\treturn \\\"#\\\";\\n\\t\\t} else {\\n\\t\\t\\treturn href.substring(idx);\\n\\t\\t}\\n\\t};\\n\\t\\n\\t/*\\n\\tPad a string to a given length with \\\"0\\\"s. Length defaults to 2\\n\\t*/\\n\\t$tw.utils.pad = function(value,length) {\\n\\t\\tlength = length || 2;\\n\\t\\tvar s = value.toString();\\n\\t\\tif(s.length < length) {\\n\\t\\t\\ts = \\\"000000000000000000000000000\\\".substr(0,length - s.length) + s;\\n\\t\\t}\\n\\t\\treturn s;\\n\\t};\\n\\t\\n\\t// Convert a date into UTC YYYYMMDDHHMMSSmmm format\\n\\t$tw.utils.stringifyDate = function(value) {\\n\\t\\treturn value.getUTCFullYear() +\\n\\t\\t\\t\\t$tw.utils.pad(value.getUTCMonth() + 1) +\\n\\t\\t\\t\\t$tw.utils.pad(value.getUTCDate()) +\\n\\t\\t\\t\\t$tw.utils.pad(value.getUTCHours()) +\\n\\t\\t\\t\\t$tw.utils.pad(value.getUTCMinutes()) +\\n\\t\\t\\t\\t$tw.utils.pad(value.getUTCSeconds()) +\\n\\t\\t\\t\\t$tw.utils.pad(value.getUTCMilliseconds(),3);\\n\\t};\\n\\t\\n\\t// Parse a date from a UTC YYYYMMDDHHMMSSmmm format string\\n\\t$tw.utils.parseDate = function(value) {\\n\\t\\tif(typeof value === \\\"string\\\") {\\n\\t\\t\\tvar negative = 1;\\n\\t\\t\\tif(value.charAt(0) === \\\"-\\\") {\\n\\t\\t\\t\\tnegative = -1;\\n\\t\\t\\t\\tvalue = value.substr(1);\\n\\t\\t\\t}\\n\\t\\t\\tvar year = parseInt(value.substr(0,4),10) * negative,\\n\\t\\t\\t\\td = new Date(Date.UTC(year,\\n\\t\\t\\t\\t\\tparseInt(value.substr(4,2),10)-1,\\n\\t\\t\\t\\t\\tparseInt(value.substr(6,2),10),\\n\\t\\t\\t\\t\\tparseInt(value.substr(8,2)||\\\"00\\\",10),\\n\\t\\t\\t\\t\\tparseInt(value.substr(10,2)||\\\"00\\\",10),\\n\\t\\t\\t\\t\\tparseInt(value.substr(12,2)||\\\"00\\\",10),\\n\\t\\t\\t\\t\\tparseInt(value.substr(14,3)||\\\"000\\\",10)));\\n\\t\\t\\t  d.setUTCFullYear(year); // See https://stackoverflow.com/a/5870822\\n\\t\\t\\t  return d;\\n\\t\\t} else if($tw.utils.isDate(value)) {\\n\\t\\t\\treturn value;\\n\\t\\t} else {\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\t};\\n\\t\\n\\t// Stringify an array of tiddler titles into a list string\\n\\t$tw.utils.stringifyList = function(value) {\\n\\t\\tif($tw.utils.isArray(value)) {\\n\\t\\t\\tvar result = new Array(value.length);\\n\\t\\t\\tfor(var t=0, l=value.length; t<l; t++) {\\n\\t\\t\\t\\tvar entry = value[t] || \\\"\\\";\\n\\t\\t\\t\\tif(entry.match(/[^\\\\S\\\\xA0]/mg)) {\\n\\t\\t\\t\\t\\tresult[t] = \\\"[[\\\" + entry + \\\"]]\\\";\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tresult[t] = entry;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn result.join(\\\" \\\");\\n\\t\\t} else {\\n\\t\\t\\treturn value || \\\"\\\";\\n\\t\\t}\\n\\t};\\n\\t\\n\\t// Parse a string array from a bracketted list. For example \\\"OneTiddler [[Another Tiddler]] LastOne\\\"\\n\\t$tw.utils.parseStringArray = function(value, allowDuplicate) {\\n\\t\\tif(typeof value === \\\"string\\\") {\\n\\t\\t\\tvar memberRegExp = /(?:^|[^\\\\S\\\\xA0])(?:\\\\[\\\\[(.*?)\\\\]\\\\])(?=[^\\\\S\\\\xA0]|$)|([\\\\S\\\\xA0]+)/mg,\\n\\t\\t\\t\\tresults = [], names = {},\\n\\t\\t\\t\\tmatch;\\n\\t\\t\\tdo {\\n\\t\\t\\t\\tmatch = memberRegExp.exec(value);\\n\\t\\t\\t\\tif(match) {\\n\\t\\t\\t\\t\\tvar item = match[1] || match[2];\\n\\t\\t\\t\\t\\tif(item !== undefined && (!$tw.utils.hop(names,item) || allowDuplicate)) {\\n\\t\\t\\t\\t\\t\\tresults.push(item);\\n\\t\\t\\t\\t\\t\\tnames[item] = true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t} while(match);\\n\\t\\t\\treturn results;\\n\\t\\t} else if($tw.utils.isArray(value)) {\\n\\t\\t\\treturn value;\\n\\t\\t} else {\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\t};\\n\\t\\n\\t// Parse a block of name:value fields. The `fields` object is used as the basis for the return value\\n\\t$tw.utils.parseFields = function(text,fields) {\\n\\t\\tfields = fields || Object.create(null);\\n\\t\\ttext.split(/\\\\r?\\\\n/mg).forEach(function(line) {\\n\\t\\t\\tif(line.charAt(0) !== \\\"#\\\") {\\n\\t\\t\\t\\tvar p = line.indexOf(\\\":\\\");\\n\\t\\t\\t\\tif(p !== -1) {\\n\\t\\t\\t\\t\\tvar field = line.substr(0, p).trim(),\\n\\t\\t\\t\\t\\t\\tvalue = line.substr(p+1).trim();\\n\\t\\t\\t\\t\\tif(field) {\\n\\t\\t\\t\\t\\t\\tfields[field] = value;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t});\\n\\t\\treturn fields;\\n\\t};\\n\\t\\n\\t// Safely parse a string as JSON\\n\\t$tw.utils.parseJSONSafe = function(text,defaultJSON) {\\n\\t\\ttry {\\n\\t\\t\\treturn JSON.parse(text);\\n\\t\\t} catch(e) {\\n\\t\\t\\tif(typeof defaultJSON === \\\"function\\\") {\\n\\t\\t\\t\\treturn defaultJSON(e);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn defaultJSON || {};\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\t\\n\\t/*\\n\\tResolves a source filepath delimited with `/` relative to a specified absolute root filepath.\\n\\tIn relative paths, the special folder name `..` refers to immediate parent directory, and the\\n\\tname `.` refers to the current directory\\n\\t*/\\n\\t$tw.utils.resolvePath = function(sourcepath,rootpath) {\\n\\t\\t// If the source path starts with ./ or ../ then it is relative to the root\\n\\t\\tif(sourcepath.substr(0,2) === \\\"./\\\" || sourcepath.substr(0,3) === \\\"../\\\" ) {\\n\\t\\t\\tvar src = sourcepath.split(\\\"/\\\"),\\n\\t\\t\\t\\troot = rootpath.split(\\\"/\\\");\\n\\t\\t\\t// Remove the filename part of the root\\n\\t\\t\\troot.splice(root.length-1,1);\\n\\t\\t\\t// Process the source path bit by bit onto the end of the root path\\n\\t\\t\\twhile(src.length > 0) {\\n\\t\\t\\t\\tvar c = src.shift();\\n\\t\\t\\t\\tif(c === \\\"..\\\") { // Slice off the last root entry for a double dot\\n\\t\\t\\t\\t\\tif(root.length > 0) {\\n\\t\\t\\t\\t\\t\\troot.splice(root.length-1,1);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} else if(c !== \\\".\\\") { // Ignore dots\\n\\t\\t\\t\\t\\troot.push(c); // Copy other elements across\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn root.join(\\\"/\\\");\\n\\t\\t} else {\\n\\t\\t\\t// If it isn't relative, just return the path\\n\\t\\t\\tif(rootpath) {\\n\\t\\t\\t\\tvar root = rootpath.split(\\\"/\\\");\\n\\t\\t\\t\\t// Remove the filename part of the root\\n\\t\\t\\t\\troot.splice(root.length - 1, 1);\\n\\t\\t\\t\\treturn root.join(\\\"/\\\") + \\\"/\\\" + sourcepath;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn sourcepath;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\t\\n\\t/*\\n\\tParse a semantic version string into its constituent parts -- see https://semver.org\\n\\t*/\\n\\t$tw.utils.parseVersion = function(version) {\\n\\t\\tvar match = /^v?((\\\\d+)\\\\.(\\\\d+)\\\\.(\\\\d+))(?:-([\\\\dA-Za-z\\\\-]+(?:\\\\.[\\\\dA-Za-z\\\\-]+)*))?(?:\\\\+([\\\\dA-Za-z\\\\-]+(?:\\\\.[\\\\dA-Za-z\\\\-]+)*))?$/.exec(version);\\n\\t\\tif(match) {\\n\\t\\t\\treturn {\\n\\t\\t\\t\\tversion: match[1],\\n\\t\\t\\t\\tmajor: parseInt(match[2],10),\\n\\t\\t\\t\\tminor: parseInt(match[3],10),\\n\\t\\t\\t\\tpatch: parseInt(match[4],10),\\n\\t\\t\\t\\tprerelease: match[5],\\n\\t\\t\\t\\tbuild: match[6]\\n\\t\\t\\t};\\n\\t\\t} else {\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\t};\\n\\t\\n\\t/*\\n\\tReturns +1 if the version string A is greater than the version string B, 0 if they are the same, and +1 if B is greater than A.\\n\\tMissing or malformed version strings are parsed as 0.0.0\\n\\t*/\\n\\t$tw.utils.compareVersions = function(versionStringA,versionStringB) {\\n\\t\\tvar defaultVersion = {\\n\\t\\t\\t\\tmajor: 0,\\n\\t\\t\\t\\tminor: 0,\\n\\t\\t\\t\\tpatch: 0\\n\\t\\t\\t},\\n\\t\\t\\tversionA = $tw.utils.parseVersion(versionStringA) || defaultVersion,\\n\\t\\t\\tversionB = $tw.utils.parseVersion(versionStringB) || defaultVersion,\\n\\t\\t\\tdiff = [\\n\\t\\t\\t\\tversionA.major - versionB.major,\\n\\t\\t\\t\\tversionA.minor - versionB.minor,\\n\\t\\t\\t\\tversionA.patch - versionB.patch\\n\\t\\t\\t];\\n\\t\\tif((diff[0] > 0) || (diff[0] === 0 && diff[1] > 0) || (diff[0] === 0 & diff[1] === 0 & diff[2] > 0)) {\\n\\t\\t\\treturn +1;\\n\\t\\t} else if((diff[0] < 0) || (diff[0] === 0 && diff[1] < 0) || (diff[0] === 0 & diff[1] === 0 & diff[2] < 0)) {\\n\\t\\t\\treturn -1;\\n\\t\\t} else {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t};\\n\\t\\n\\t/*\\n\\tReturns true if the version string A is greater than the version string B. Returns true if the versions are the same\\n\\t*/\\n\\t$tw.utils.checkVersions = function(versionStringA,versionStringB) {\\n\\t\\treturn $tw.utils.compareVersions(versionStringA,versionStringB) !== -1;\\n\\t};\\n\\t\\n\\t/*\\n\\tRegister file type information\\n\\toptions: {flags: flags,deserializerType: deserializerType}\\n\\t\\tflags:\\\"image\\\" for image types\\n\\t\\tdeserializerType: defaults to type if not specified\\n\\t*/\\n\\t$tw.utils.registerFileType = function(type,encoding,extension,options) {\\n\\t\\toptions = options || {};\\n\\t\\tif($tw.utils.isArray(extension)) {\\n\\t\\t\\t$tw.utils.each(extension,function(extension) {\\n\\t\\t\\t\\t$tw.config.fileExtensionInfo[extension] = {type: type};\\n\\t\\t\\t});\\n\\t\\t\\textension = extension[0];\\n\\t\\t} else {\\n\\t\\t\\t$tw.config.fileExtensionInfo[extension] = {type: type};\\n\\t\\t}\\n\\t\\t$tw.config.contentTypeInfo[type] = {encoding: encoding, extension: extension, flags: options.flags || [], deserializerType: options.deserializerType || type};\\n\\t};\\n\\t\\n\\t/*\\n\\tGiven an extension, always access the $tw.config.fileExtensionInfo\\n\\tusing a lowercase extension only.\\n\\t*/\\n\\t$tw.utils.getFileExtensionInfo = function(ext) {\\n\\t\\treturn ext ? $tw.config.fileExtensionInfo[ext.toLowerCase()] : null;\\n\\t}\\n\\t\\n\\t/*\\n\\tGiven an extension, get the correct encoding for that file.\\n\\tdefaults to utf8\\n\\t*/\\n\\t$tw.utils.getTypeEncoding = function(ext) {\\n\\t\\tvar extensionInfo = $tw.utils.getFileExtensionInfo(ext),\\n\\t\\t\\ttype = extensionInfo ? extensionInfo.type : null,\\n\\t\\t\\ttypeInfo = type ? $tw.config.contentTypeInfo[type] : null;\\n\\t\\treturn typeInfo ? typeInfo.encoding : \\\"utf8\\\";\\n\\t};\\n\\t\\n\\tvar globalCheck =[\\n\\t\\t\\\"  Object.defineProperty(Object.prototype, '__temp__', {\\\",\\n\\t\\t\\\"    get: function () { return this; },\\\",\\n\\t\\t\\\"    configurable: true\\\",\\n\\t\\t\\\"  });\\\",\\n\\t\\t\\\"  if(Object.keys(__temp__).length){\\\",\\n\\t\\t\\\"    console.log(\\\\\\\"Warning: Global assignment detected\\\\\\\",Object.keys(__temp__));\\\",\\n\\t\\t\\\"    delete Object.prototype.__temp__;\\\",\\n\\t\\t\\\"  }\\\",\\n\\t\\t\\\"  delete Object.prototype.__temp__;\\\",\\n\\t].join('\\\\n');\\n\\t\\n\\t/*\\n\\tRun code globally with specified context variables in scope\\n\\t*/\\n\\t$tw.utils.evalGlobal = function(code,context,filename,sandbox,allowGlobals) {\\n\\t\\tvar contextCopy = $tw.utils.extend(Object.create(null),context);\\n\\t\\t// Get the context variables as a pair of arrays of names and values\\n\\t\\tvar contextNames = [], contextValues = [];\\n\\t\\t$tw.utils.each(contextCopy,function(value,name) {\\n\\t\\t\\tcontextNames.push(name);\\n\\t\\t\\tcontextValues.push(value);\\n\\t\\t});\\n\\t\\t// Add the code prologue and epilogue\\n\\t\\tcode = [\\n\\t\\t\\t\\\"(function(\\\" + contextNames.join(\\\",\\\") + \\\") {\\\",\\n\\t\\t\\t\\\"  (function(){\\\" + code + \\\"\\\\n;})();\\\\n\\\",\\n\\t\\t\\t(!$tw.browser && sandbox && !allowGlobals) ? globalCheck : \\\"\\\",\\n\\t\\t\\t\\\"\\\\nreturn exports;\\\\n\\\",\\n\\t\\t\\t\\\"})\\\"\\n\\t\\t].join(\\\"\\\");\\n\\t\\n\\t\\t// Compile the code into a function\\n\\t\\tvar fn;\\n\\t\\tif($tw.browser) {\\n\\t\\t\\tfn = window[\\\"eval\\\"](code + \\\"\\\\n\\\\n//# sourceURL=\\\" + filename);\\n\\t\\t} else {\\n\\t\\t\\tif(sandbox){\\n\\t\\t\\t\\tfn = vm.runInContext(code,sandbox,filename)\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tfn = vm.runInThisContext(code,filename);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// Call the function and return the exports\\n\\t\\treturn fn.apply(null,contextValues);\\n\\t};\\n\\t$tw.utils.sandbox = !$tw.browser ? vm.createContext({}) : undefined; \\n\\t/*\\n\\tRun code in a sandbox with only the specified context variables in scope\\n\\t*/\\n\\t$tw.utils.evalSandboxed = $tw.browser ? $tw.utils.evalGlobal : function(code,context,filename,allowGlobals) {\\n\\t\\treturn $tw.utils.evalGlobal(\\n\\t\\t\\tcode,context,filename,\\n\\t\\t\\tallowGlobals ? vm.createContext({}) : $tw.utils.sandbox,\\n\\t\\t\\tallowGlobals\\n\\t\\t);\\n\\t};\\n\\t\\n\\t/*\\n\\tCreates a PasswordPrompt object\\n\\t*/\\n\\t$tw.utils.PasswordPrompt = function() {\\n\\t\\t// Store of pending password prompts\\n\\t\\tthis.passwordPrompts = [];\\n\\t\\t// Create the wrapper\\n\\t\\tthis.promptWrapper = $tw.utils.domMaker(\\\"div\\\",{\\\"class\\\":\\\"tc-password-wrapper\\\"});\\n\\t\\tdocument.body.appendChild(this.promptWrapper);\\n\\t\\t// Hide the empty wrapper\\n\\t\\tthis.setWrapperDisplay();\\n\\t};\\n\\t\\n\\t/*\\n\\tHides or shows the wrapper depending on whether there are any outstanding prompts\\n\\t*/\\n\\t$tw.utils.PasswordPrompt.prototype.setWrapperDisplay = function() {\\n\\t\\tif(this.passwordPrompts.length) {\\n\\t\\t\\tthis.promptWrapper.style.display = \\\"block\\\";\\n\\t\\t} else {\\n\\t\\t\\tthis.promptWrapper.style.display = \\\"none\\\";\\n\\t\\t}\\n\\t};\\n\\t\\n\\t/*\\n\\tAdds a new password prompt. Options are:\\n\\tsubmitText: text to use for submit button (defaults to \\\"Login\\\")\\n\\tserviceName: text of the human readable service name\\n\\tnoUserName: set true to disable username prompt\\n\\tcanCancel: set true to enable a cancel button (callback called with null)\\n\\trepeatPassword: set true to prompt for the password twice\\n\\tcallback: function to be called on submission with parameter of object {username:,password:}. Callback must return `true` to remove the password prompt\\n\\t*/\\n\\t$tw.utils.PasswordPrompt.prototype.createPrompt = function(options) {\\n\\t\\t// Create and add the prompt to the DOM\\n\\t\\tvar self = this,\\n\\t\\t\\tsubmitText = options.submitText || \\\"Login\\\",\\n\\t\\t\\tdm = $tw.utils.domMaker,\\n\\t\\t\\tchildren = [dm(\\\"h1\\\",{text: options.serviceName})];\\n\\t\\tif(!options.noUserName) {\\n\\t\\t\\tchildren.push(dm(\\\"input\\\",{\\n\\t\\t\\t\\tattributes: {type: \\\"text\\\", name: \\\"username\\\", placeholder: $tw.language.getString(\\\"Encryption/Username\\\")}\\n\\t\\t\\t}));\\n\\t\\t}\\n\\t\\tchildren.push(dm(\\\"input\\\",{\\n\\t\\t\\tattributes: {\\n\\t\\t\\t\\ttype: \\\"password\\\",\\n\\t\\t\\t\\tname: \\\"password\\\",\\n\\t\\t\\t\\tplaceholder: ( $tw.language == undefined ? \\\"Password\\\" : $tw.language.getString(\\\"Encryption/Password\\\") )\\n\\t\\t\\t}\\n\\t\\t}));\\n\\t\\tif(options.repeatPassword) {\\n\\t\\t\\tchildren.push(dm(\\\"input\\\",{\\n\\t\\t\\t\\tattributes: {\\n\\t\\t\\t\\t\\ttype: \\\"password\\\",\\n\\t\\t\\t\\t\\tname: \\\"password2\\\",\\n\\t\\t\\t\\t\\tplaceholder: $tw.language.getString(\\\"Encryption/RepeatPassword\\\")\\n\\t\\t\\t\\t}\\n\\t\\t\\t}));\\n\\t\\t}\\n\\t\\tif(options.canCancel) {\\n\\t\\t\\tchildren.push(dm(\\\"button\\\",{\\n\\t\\t\\t\\ttext: $tw.language.getString(\\\"Encryption/Cancel\\\"),\\n\\t\\t\\t\\tattributes: {\\n\\t\\t\\t\\t\\ttype: \\\"button\\\"\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\teventListeners: [{\\n\\t\\t\\t\\t\\t\\tname: \\\"click\\\",\\n\\t\\t\\t\\t\\t\\thandlerFunction: function(event) {\\n\\t\\t\\t\\t\\t\\t\\tself.removePrompt(promptInfo);\\n\\t\\t\\t\\t\\t\\t\\toptions.callback(null);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}]\\n\\t\\t\\t}));\\n\\t\\t}\\n\\t\\tchildren.push(dm(\\\"button\\\",{\\n\\t\\t\\tattributes: {type: \\\"submit\\\"},\\n\\t\\t\\ttext: submitText\\n\\t\\t}));\\n\\t\\tvar form = dm(\\\"form\\\",{\\n\\t\\t\\tattributes: {autocomplete: \\\"off\\\"},\\n\\t\\t\\tchildren: children\\n\\t\\t});\\n\\t\\tthis.promptWrapper.appendChild(form);\\n\\t\\twindow.setTimeout(function() {\\n\\t\\t\\tform.elements[0].focus();\\n\\t\\t},10);\\n\\t\\t// Add a submit event handler\\n\\t\\tvar self = this;\\n\\t\\tform.addEventListener(\\\"submit\\\",function(event) {\\n\\t\\t\\t// Collect the form data\\n\\t\\t\\tvar data = {},t;\\n\\t\\t\\t$tw.utils.each(form.elements,function(element) {\\n\\t\\t\\t\\tif(element.name && element.value) {\\n\\t\\t\\t\\t\\tdata[element.name] = element.value;\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\t\\t\\t// Check that the passwords match\\n\\t\\t\\tif(options.repeatPassword && data.password !== data.password2) {\\n\\t\\t\\t\\talert($tw.language.getString(\\\"Encryption/PasswordNoMatch\\\"));\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// Call the callback\\n\\t\\t\\t\\tif(options.callback(data)) {\\n\\t\\t\\t\\t\\t// Remove the prompt if the callback returned true\\n\\t\\t\\t\\t\\tself.removePrompt(promptInfo);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t// Clear the password if the callback returned false\\n\\t\\t\\t\\t\\t$tw.utils.each(form.elements,function(element) {\\n\\t\\t\\t\\t\\t\\tif(element.name === \\\"password\\\" || element.name === \\\"password2\\\") {\\n\\t\\t\\t\\t\\t\\t\\telement.value = \\\"\\\";\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tevent.preventDefault();\\n\\t\\t\\treturn false;\\n\\t\\t},true);\\n\\t\\t// Add the prompt to the list\\n\\t\\tvar promptInfo = {\\n\\t\\t\\tserviceName: options.serviceName,\\n\\t\\t\\tcallback: options.callback,\\n\\t\\t\\tform: form,\\n\\t\\t\\towner: this\\n\\t\\t};\\n\\t\\tthis.passwordPrompts.push(promptInfo);\\n\\t\\t// Make sure the wrapper is displayed\\n\\t\\tthis.setWrapperDisplay();\\n\\t\\treturn promptInfo;\\n\\t};\\n\\t\\n\\t$tw.utils.PasswordPrompt.prototype.removePrompt = function(promptInfo) {\\n\\t\\tvar i = this.passwordPrompts.indexOf(promptInfo);\\n\\t\\tif(i !== -1) {\\n\\t\\t\\tthis.passwordPrompts.splice(i,1);\\n\\t\\t\\tpromptInfo.form.parentNode.removeChild(promptInfo.form);\\n\\t\\t\\tthis.setWrapperDisplay();\\n\\t\\t}\\n\\t}\\n\\t\\n\\t/*\\n\\tCrypto helper object for encrypted content. It maintains the password text in a closure, and provides methods to change\\n\\tthe password, and to encrypt/decrypt a block of text\\n\\t*/\\n\\t$tw.utils.Crypto = function() {\\n\\t\\tvar sjcl = $tw.node ? (global.sjcl || require(\\\"./sjcl.js\\\")) : window.sjcl,\\n\\t\\t\\tcurrentPassword = null,\\n\\t\\t\\tcallSjcl = function(method,inputText,password) {\\n\\t\\t\\t\\tpassword = password || currentPassword;\\n\\t\\t\\t\\tvar outputText;\\n\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\tif(password) {\\n\\t\\t\\t\\t\\t\\toutputText = sjcl[method](password,inputText);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} catch(ex) {\\n\\t\\t\\t\\t\\tconsole.log(\\\"Crypto error:\\\" + ex);\\n\\t\\t\\t\\t\\toutputText = null;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn outputText;\\n\\t\\t\\t};\\n\\t\\t$tw.sjcl = sjcl;\\n\\t\\tthis.setPassword = function(newPassword) {\\n\\t\\t\\tcurrentPassword = newPassword;\\n\\t\\t\\tthis.updateCryptoStateTiddler();\\n\\t\\t};\\n\\t\\tthis.updateCryptoStateTiddler = function() {\\n\\t\\t\\tif($tw.wiki) {\\n\\t\\t\\t\\tvar state = currentPassword ? \\\"yes\\\" : \\\"no\\\",\\n\\t\\t\\t\\t\\ttiddler = $tw.wiki.getTiddler(\\\"$:/isEncrypted\\\");\\n\\t\\t\\t\\tif(!tiddler || tiddler.fields.text !== state) {\\n\\t\\t\\t\\t\\t$tw.wiki.addTiddler(new $tw.Tiddler({title: \\\"$:/isEncrypted\\\", text: state}));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\tthis.hasPassword = function() {\\n\\t\\t\\treturn !!currentPassword;\\n\\t\\t}\\n\\t\\tthis.encrypt = function(text,password) {\\n\\t\\t\\treturn callSjcl(\\\"encrypt\\\",text,password);\\n\\t\\t};\\n\\t\\tthis.decrypt = function(text,password) {\\n\\t\\t\\treturn callSjcl(\\\"decrypt\\\",text,password);\\n\\t\\t};\\n\\t};\\n\\t\\n\\t$tw.utils.CSE = function () {\\n\\t\\tvar currentPassword = null;\\n\\t\\tthis.setPassword = function(newPassword) {\\n\\t\\t\\tcurrentPassword = newPassword;\\n\\t\\t\\tif($tw.CSE.launched){\\n\\t\\t\\t\\tvar isRemembered = $tw.wiki.getTiddlerData(\\\"$:/plugins/FSpark/TW5-CSE/metaconfig.json\\\")\\n\\t\\t\\t\\tif(isRemembered && isRemembered[\\\"RmbPwd\\\"]===\\\"yes\\\"){\\n\\t\\t\\t\\t\\tthis.rememberPassword();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tthis.updateCryptoStateTiddler();\\n\\t\\t};\\n\\t\\tthis.rememberPassword = function (){\\n\\t\\t\\tif(window && window.localStorage){\\n\\t\\t\\t\\twindow.localStorage.setItem(\\\"tw5-cse-pwd\\\", currentPassword);\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\tthis.forgetPassword =  function (){\\n\\t\\t\\tif(window && window.localStorage){\\n\\t\\t\\t\\twindow.localStorage.removeItem(\\\"tw5-cse-pwd\\\");\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\tthis.updateCryptoStateTiddler = function() {\\n\\t\\t\\tif($tw.wiki) {\\n\\t\\t\\t\\tvar state = currentPassword ? \\\"yes\\\" : \\\"no\\\",\\n\\t\\t\\t\\t\\ttiddler = $tw.wiki.getTiddler(\\\"$:/isCSEncrypted\\\");\\n\\t\\t\\t\\tif(!tiddler || tiddler.fields.text !== state) {\\n\\t\\t\\t\\t\\t$tw.wiki.addTiddler(new $tw.Tiddler({title: \\\"$:/isCSEncrypted\\\", text: state}));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\tthis.forcePush = function (filter, widget) {\\n\\t\\t\\tdebugger;\\n\\t\\t\\tfilter = filter || $tw.wiki.getTiddlerText('$:/config/TW5-CSE/EncryptFilter',\\\"[all[]!is[system]]\\\")\\n\\t\\n\\t\\t\\twidget = widget || $tw.rootWidget\\n\\t\\n\\t\\t\\tvar filterTiddlers = $tw.wiki.filterTiddlers(filter, widget)\\n\\t\\t\\tvar filterTiddlersLength = filterTiddlers.length\\n\\t\\n\\t\\t\\tfilterTiddlers.forEach(function (title)  {\\n\\t\\t\\t\\tif($tw.utils.hop($tw.wiki.changeCount, title)) {\\n\\t\\t\\t\\t\\t$tw.wiki.changeCount[title]++;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t$tw.wiki.changeCount[title] = 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t})\\n\\t\\n\\t\\t\\tvar id = $tw.wiki.getTiddlerText('$:/temp/CSE-IntervalID')\\n\\t\\t\\tif(id) clearTimeout(parseInt(id))\\n\\t\\t\\tvar self = this;\\n\\t\\t\\t$tw.modal.display(\\\"$:/plugins/FSpark/TW5-CSE/ui/PushingModal\\\")\\n\\t\\t\\tvar startTime = Date.now();\\n\\t\\t\\tid = setInterval(function() {\\n\\t\\t\\t\\tif($tw.syncer.isDirty()){\\n\\t\\t\\t\\t\\t// Filter out unsynced\\n\\t\\t\\t\\t\\tfilterTiddlers = filterTiddlers.filter(function (title) {\\n\\t\\t\\t\\t\\t\\treturn !$tw.syncer.tiddlerInfo[title] || $tw.wiki.getChangeCount(title) > $tw.syncer.tiddlerInfo[title].changeCount\\n\\t\\t\\t\\t\\t})\\n\\t\\t\\t\\t\\tvar syncedTiddlers = filterTiddlersLength - filterTiddlers.length\\n\\t\\t\\t\\t\\tvar percentComplete = (syncedTiddlers * 100 / filterTiddlersLength).toFixed(2)  + '%'\\n\\t\\n\\t\\t\\t\\t\\tvar endTime = Date.now(); \\n\\t\\t\\t\\t\\tvar timeElapsed = (endTime - startTime) / 1000;\\n\\t\\t\\t\\t\\tvar syncSpeed = syncedTiddlers / timeElapsed;\\n\\t\\t\\t\\t\\tvar remainingTiddlersSize = filterTiddlers.length; \\n\\t\\t\\t\\t\\tvar remainingTime = remainingTiddlersSize / syncSpeed;\\n\\t\\n\\t\\t\\t\\t\\tvar hours = Math.floor(remainingTime / 3600).toString().padStart(2, '0');\\n\\t\\t\\t\\t\\tvar minutes = Math.floor((remainingTime % 3600) / 60).toString().padStart(2, '0');\\n\\t\\t\\t\\t\\tvar seconds = Math.floor(remainingTime % 60).toString().padStart(2, '0');\\n\\t\\n\\t\\t\\t\\t\\t$tw.wiki.addTiddler({\\n\\t\\t\\t\\t\\t\\ttitle: \\\"$:/temp/CSENumTasksInProgress\\\",\\n\\t\\t\\t\\t\\t\\ttext: `${syncedTiddlers}/${filterTiddlersLength} ${percentComplete}` })\\n\\t\\t\\t\\t\\t$tw.wiki.addTiddler({\\n\\t\\t\\t\\t\\t\\ttitle: \\\"$:/temp/CSESyncEstimatedTimeLeft\\\",\\n\\t\\t\\t\\t\\t\\ttext: `Estimated time left: ${hours}:${minutes}:${seconds}` })\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\t// debugger;\\n\\t\\t\\t\\t\\t$tw.wiki.addTiddler({title: \\\"$:/state/cse-modal-close\\\", text: \\\"yes\\\"})\\n\\t\\t\\t\\t\\tclearTimeout(id)\\n\\t\\t\\t\\t\\t$tw.wiki.deleteTiddler(\\\"$:/temp/CSE-IntervalID\\\")\\n\\t\\t\\t\\t\\t$tw.wiki.deleteTiddler(\\\"$:/temp/CSENumTasksInProgress\\\")\\n\\t\\t\\t\\t}\\n\\t\\t\\t}, 500);\\n\\t\\t\\t$tw.wiki.addTiddler({title: \\\"$:/temp/CSE-IntervalID\\\",text: id.toString()})\\n\\t\\t}\\n\\t\\tthis.saveTiddler = function (tiddler, fields) {\\n\\t\\t\\tdebugger;\\n\\t\\t\\t$tw.wiki.addTiddler(\\n\\t\\t\\t\\tnew $tw.Tiddler(\\n\\t\\t\\t\\t\\t// $tw.wiki.getModificationFields(),\\n\\t\\t\\t\\t\\ttiddler,\\n\\t\\t\\t\\t\\tthis.clearNonStandardFields(tiddler),\\n\\t\\t\\t\\t\\tfields\\n\\t\\t\\t\\t)\\n\\t\\t\\t);\\n\\t\\t};\\n\\t\\tthis.encryptFields = function (title, password) {\\n\\t\\t\\tpassword = password || currentPassword;\\n\\t\\t\\tvar jsonData = $tw.wiki.getTiddlerAsJson(title);\\n\\t\\t\\treturn $tw.crypto.encrypt(jsonData, password);\\n\\t\\t};\\n\\t\\n\\t\\tthis.decryptFields = function (fields, password) {\\n\\t\\t\\tpassword = password || currentPassword;\\n\\t\\t\\tvar JSONfields = $tw.crypto.decrypt(fields.encrypted, password);\\n\\t\\t\\tif(!!JSONfields) {\\n\\t\\t\\t\\treturn JSON.parse(JSONfields);\\n\\t\\t\\t}\\n\\t\\t\\tconsole.log(\\n\\t\\t\\t\\t\\\"Error decrypting \\\" + fields.title + \\\". Probably bad password\\\"\\n\\t\\t\\t);\\n\\t\\t\\treturn false;\\n\\t\\t};\\n\\t\\tthis.clearNonStandardFields = function (tiddler) {\\n\\t\\t\\tvar standardFieldNames =\\n\\t\\t\\t\\t\\\"title tags modified modifier created creator\\\".split(\\\" \\\");\\n\\t\\t\\tvar clearFields = {};\\n\\t\\t\\tfor(var fieldName in tiddler.fields) {\\n\\t\\t\\t\\tif(standardFieldNames.indexOf(fieldName) === -1) {\\n\\t\\t\\t\\t\\tclearFields[fieldName] = undefined;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tconsole.log(\\\"Cleared fields \\\" + JSON.stringify(clearFields));\\n\\t\\t\\treturn clearFields;\\n\\t\\t};\\n\\t}\\n\\t/////////////////////////// Module mechanism\\n\\t\\n\\t/*\\n\\tExecute the module named 'moduleName'. The name can optionally be relative to the module named 'moduleRoot'\\n\\t*/\\n\\t$tw.modules.execute = function(moduleName,moduleRoot) {\\n\\t\\tvar name = moduleName;\\n\\t\\tif(moduleName.charAt(0) === \\\".\\\") {\\n\\t\\t\\tname = $tw.utils.resolvePath(moduleName,moduleRoot)\\n\\t\\t}\\n\\t\\tif(!$tw.modules.titles[name]) {\\n\\t\\t\\tif($tw.modules.titles[name + \\\".js\\\"]) {\\n\\t\\t\\t\\tname = name + \\\".js\\\";\\n\\t\\t\\t} else if($tw.modules.titles[name + \\\"/index.js\\\"]) {\\n\\t\\t\\t\\tname = name + \\\"/index.js\\\";\\n\\t\\t\\t} else if($tw.modules.titles[moduleName]) {\\n\\t\\t\\t\\tname = moduleName;\\n\\t\\t\\t} else if($tw.modules.titles[moduleName + \\\".js\\\"]) {\\n\\t\\t\\t\\tname = moduleName + \\\".js\\\";\\n\\t\\t\\t} else if($tw.modules.titles[moduleName + \\\"/index.js\\\"]) {\\n\\t\\t\\t\\tname = moduleName + \\\"/index.js\\\";\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tvar moduleInfo = $tw.modules.titles[name],\\n\\t\\t\\ttiddler = $tw.wiki.getTiddler(name),\\n\\t\\t\\t_exports = {},\\n\\t\\t\\tsandbox = {\\n\\t\\t\\t\\tmodule: {exports: _exports},\\n\\t\\t\\t\\t//moduleInfo: moduleInfo,\\n\\t\\t\\t\\texports: _exports,\\n\\t\\t\\t\\tconsole: console,\\n\\t\\t\\t\\tsetInterval: setInterval,\\n\\t\\t\\t\\tclearInterval: clearInterval,\\n\\t\\t\\t\\tsetTimeout: setTimeout,\\n\\t\\t\\t\\tclearTimeout: clearTimeout,\\n\\t\\t\\t\\tBuffer: $tw.browser ? undefined : Buffer,\\n\\t\\t\\t\\t$tw: $tw,\\n\\t\\t\\t\\trequire: function(title) {\\n\\t\\t\\t\\t\\treturn $tw.modules.execute(title, name);\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\t\\n\\t\\tObject.defineProperty(sandbox.module, \\\"id\\\", {\\n\\t\\t\\tvalue: name,\\n\\t\\t\\twritable: false,\\n\\t\\t\\tenumerable: true,\\n\\t\\t\\tconfigurable: false\\n\\t\\t});\\n\\t\\n\\t\\tif(!$tw.browser) {\\n\\t\\t\\t$tw.utils.extend(sandbox,{\\n\\t\\t\\t\\tprocess: process\\n\\t\\t\\t});\\n\\t\\t} else {\\n\\t\\t\\t/*\\n\\t\\t\\tCommonJS optional require.main property:\\n\\t\\t\\t\\tIn a browser we offer a fake main module which points back to the boot function\\n\\t\\t\\t\\t(Theoretically, this may allow TW to eventually load itself as a module in the browser)\\n\\t\\t\\t*/\\n\\t\\t\\tObject.defineProperty(sandbox.require, \\\"main\\\", {\\n\\t\\t\\t\\tvalue: (typeof(require) !== \\\"undefined\\\") ? require.main : {TiddlyWiki: _boot},\\n\\t\\t\\t\\twritable: false,\\n\\t\\t\\t\\tenumerable: true,\\n\\t\\t\\t\\tconfigurable: false\\n\\t\\t\\t});\\n\\t\\t}\\n\\t\\tif(!moduleInfo) {\\n\\t\\t\\t// We could not find the module on this path\\n\\t\\t\\t// Try to defer to browserify etc, or node\\n\\t\\t\\tvar deferredModule;\\n\\t\\t\\tif($tw.browser) {\\n\\t\\t\\t\\tif(window.require) {\\n\\t\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\t\\treturn window.require(moduleName);\\n\\t\\t\\t\\t\\t} catch(e) {}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tthrow \\\"Cannot find module named '\\\" + moduleName + \\\"' required by module '\\\" + moduleRoot + \\\"', resolved to \\\" + name;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// If we don't have a module with that name, let node.js try to find it\\n\\t\\t\\t\\treturn require(moduleName);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// Execute the module if we haven't already done so\\n\\t\\tif(!moduleInfo.exports) {\\n\\t\\t\\ttry {\\n\\t\\t\\t\\t// Check the type of the definition\\n\\t\\t\\t\\tif(typeof moduleInfo.definition === \\\"function\\\") { // Function\\n\\t\\t\\t\\t\\tmoduleInfo.exports = _exports;\\n\\t\\t\\t\\t\\tmoduleInfo.definition(moduleInfo,moduleInfo.exports,sandbox.require);\\n\\t\\t\\t\\t} else if(typeof moduleInfo.definition === \\\"string\\\") { // String\\n\\t\\t\\t\\t\\tmoduleInfo.exports = _exports;\\n\\t\\t\\t\\t\\t$tw.utils.evalSandboxed(moduleInfo.definition,sandbox,tiddler.fields.title);\\n\\t\\t\\t\\t\\tif(sandbox.module.exports) {\\n\\t\\t\\t\\t\\t\\tmoduleInfo.exports = sandbox.module.exports; //more codemirror workaround\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} else { // Object\\n\\t\\t\\t\\t\\tmoduleInfo.exports = moduleInfo.definition;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} catch(e) {\\n\\t\\t\\t\\tif(e instanceof SyntaxError) {\\n\\t\\t\\t\\t\\tvar line = e.lineNumber || e.line; // Firefox || Safari\\n\\t\\t\\t\\t\\tif(typeof(line) != \\\"undefined\\\" && line !== null) {\\n\\t\\t\\t\\t\\t\\t$tw.utils.error(\\\"Syntax error in boot module \\\" + name + \\\":\\\" + line + \\\":\\\\n\\\" + e.stack);\\n\\t\\t\\t\\t\\t} else if(!$tw.browser) {\\n\\t\\t\\t\\t\\t\\t// this is the only way to get node.js to display the line at which the syntax error appeared,\\n\\t\\t\\t\\t\\t\\t// and $tw.utils.error would exit anyway\\n\\t\\t\\t\\t\\t\\t// cf. https://bugs.chromium.org/p/v8/issues/detail?id=2589\\n\\t\\t\\t\\t\\t\\tthrow e;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t// Opera: line number is included in e.message\\n\\t\\t\\t\\t\\t\\t// Chrome/IE: there's currently no way to get the line number\\n\\t\\t\\t\\t\\t\\t$tw.utils.error(\\\"Syntax error in boot module \\\" + name + \\\": \\\" + e.message + \\\"\\\\n\\\" + e.stack);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t// line number should be included in e.stack for runtime errors\\n\\t\\t\\t\\t\\t$tw.utils.error(\\\"Error executing boot module \\\" + name + \\\": \\\" + String(e) + \\\"\\\\n\\\\n\\\" + e.stack);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// Return the exports of the module\\n\\t\\treturn moduleInfo.exports;\\n\\t};\\n\\t\\n\\t/*\\n\\tApply a callback to each module of a particular type\\n\\t\\tmoduleType: type of modules to enumerate\\n\\t\\tcallback: function called as callback(title,moduleExports) for each module\\n\\t*/\\n\\t$tw.modules.forEachModuleOfType = function(moduleType,callback) {\\n\\t\\tvar modules = $tw.modules.types[moduleType];\\n\\t\\t$tw.utils.each(modules,function(element,title) {\\n\\t\\t\\tcallback(title,$tw.modules.execute(title));\\n\\t\\t});\\n\\t};\\n\\t\\n\\t/*\\n\\tGet all the modules of a particular type in a hashmap by their `name` field\\n\\t*/\\n\\t$tw.modules.getModulesByTypeAsHashmap = function(moduleType,nameField) {\\n\\t\\tnameField = nameField || \\\"name\\\";\\n\\t\\tvar results = Object.create(null);\\n\\t\\t$tw.modules.forEachModuleOfType(moduleType,function(title,module) {\\n\\t\\t\\tresults[module[nameField]] = module;\\n\\t\\t});\\n\\t\\treturn results;\\n\\t};\\n\\t\\n\\t/*\\n\\tApply the exports of the modules of a particular type to a target object\\n\\t*/\\n\\t$tw.modules.applyMethods = function(moduleType,targetObject) {\\n\\t\\tif(!targetObject) {\\n\\t\\t\\ttargetObject = Object.create(null);\\n\\t\\t}\\n\\t\\t$tw.modules.forEachModuleOfType(moduleType,function(title,module) {\\n\\t\\t\\t$tw.utils.each(module,function(element,title,object) {\\n\\t\\t\\t\\ttargetObject[title] = module[title];\\n\\t\\t\\t});\\n\\t\\t});\\n\\t\\treturn targetObject;\\n\\t};\\n\\t\\n\\t/*\\n\\tReturn a class created from a modules. The module should export the properties to be added to those of the optional base class\\n\\t*/\\n\\t$tw.modules.createClassFromModule = function(moduleExports,baseClass) {\\n\\t\\tvar newClass = function() {};\\n\\t\\tif(baseClass) {\\n\\t\\t\\tnewClass.prototype = new baseClass();\\n\\t\\t\\tnewClass.prototype.constructor = baseClass;\\n\\t\\t}\\n\\t\\t$tw.utils.extend(newClass.prototype,moduleExports);\\n\\t\\treturn newClass;\\n\\t};\\n\\t\\n\\t/*\\n\\tReturn an array of classes created from the modules of a specified type. Each module should export the properties to be added to those of the optional base class\\n\\t*/\\n\\t$tw.modules.createClassesFromModules = function(moduleType,subType,baseClass) {\\n\\t\\tvar classes = Object.create(null);\\n\\t\\t$tw.modules.forEachModuleOfType(moduleType,function(title,moduleExports) {\\n\\t\\t\\tif(!subType || moduleExports.types[subType]) {\\n\\t\\t\\t\\tclasses[moduleExports.name] = $tw.modules.createClassFromModule(moduleExports,baseClass);\\n\\t\\t\\t}\\n\\t\\t});\\n\\t\\treturn classes;\\n\\t};\\n\\t\\n\\t/////////////////////////// Barebones tiddler object\\n\\t\\n\\t/*\\n\\tConstruct a tiddler object from a hashmap of tiddler fields. If multiple hasmaps are provided they are merged,\\n\\ttaking precedence to the right\\n\\t*/\\n\\t$tw.Tiddler = function(/* [fields,] fields */) {\\n\\t\\tthis.fields = Object.create(null);\\n\\t\\tthis.cache = Object.create(null);\\n\\t\\tfor(var c=0; c<arguments.length; c++) {\\n\\t\\t\\tvar arg = arguments[c],\\n\\t\\t\\t\\tsrc = (arg instanceof $tw.Tiddler) ? arg.fields : arg;\\n\\t\\t\\tfor(var t in src) {\\n\\t\\t\\t\\tif(src[t] === undefined || src[t] === null) {\\n\\t\\t\\t\\t\\tif(t in this.fields) {\\n\\t\\t\\t\\t\\t\\tdelete this.fields[t]; // If we get a field that's undefined, delete any previous field value\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t// Parse the field with the associated field module (if any)\\n\\t\\t\\t\\t\\tvar fieldModule = $tw.Tiddler.fieldModules[t],\\n\\t\\t\\t\\t\\t\\tvalue;\\n\\t\\t\\t\\t\\tif(fieldModule && fieldModule.parse) {\\n\\t\\t\\t\\t\\t\\tvalue = fieldModule.parse.call(this,src[t]);\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tvalue = src[t];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t// Freeze the field to keep it immutable\\n\\t\\t\\t\\t\\tif(value != null && typeof value === \\\"object\\\") {\\n\\t\\t\\t\\t\\t\\tObject.freeze(value);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tthis.fields[t] = value;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// Freeze the tiddler against modification\\n\\t\\tObject.freeze(this.fields);\\n\\t\\tObject.freeze(this);\\n\\t};\\n\\t\\n\\t$tw.Tiddler.prototype.hasField = function(field) {\\n\\t\\treturn $tw.utils.hop(this.fields,field);\\n\\t};\\n\\t\\n\\t/*\\n\\tCompare two tiddlers for equality\\n\\ttiddler: the tiddler to compare\\n\\texcludeFields: array of field names to exclude from the comparison\\n\\t*/\\n\\t$tw.Tiddler.prototype.isEqual = function(tiddler,excludeFields) {\\n\\t\\tif(!(tiddler instanceof $tw.Tiddler)) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\texcludeFields = excludeFields || [];\\n\\t\\tvar self = this,\\n\\t\\t\\tdifferences = []; // Fields that have differences\\n\\t\\t// Add to the differences array\\n\\t\\tfunction addDifference(fieldName) {\\n\\t\\t\\t// Check for this field being excluded\\n\\t\\t\\tif(excludeFields.indexOf(fieldName) === -1) {\\n\\t\\t\\t\\t// Save the field as a difference\\n\\t\\t\\t\\t$tw.utils.pushTop(differences,fieldName);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// Returns true if the two values of this field are equal\\n\\t\\tfunction isFieldValueEqual(fieldName) {\\n\\t\\t\\tvar valueA = self.fields[fieldName],\\n\\t\\t\\t\\tvalueB = tiddler.fields[fieldName];\\n\\t\\t\\t// Check for identical string values\\n\\t\\t\\tif(typeof(valueA) === \\\"string\\\" && typeof(valueB) === \\\"string\\\" && valueA === valueB) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t\\t// Check for identical array values\\n\\t\\t\\tif($tw.utils.isArray(valueA) && $tw.utils.isArray(valueB) && $tw.utils.isArrayEqual(valueA,valueB)) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t\\t// Check for identical date values\\n\\t\\t\\tif($tw.utils.isDate(valueA) && $tw.utils.isDate(valueB) && valueA.getTime() === valueB.getTime()) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t\\t// Otherwise the fields must be different\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\t// Compare our fields\\n\\t\\tfor(var fieldName in this.fields) {\\n\\t\\t\\tif(!isFieldValueEqual(fieldName)) {\\n\\t\\t\\t\\taddDifference(fieldName);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// There's a difference for every field in the other tiddler that we don't have\\n\\t\\tfor(fieldName in tiddler.fields) {\\n\\t\\t\\tif(!(fieldName in this.fields)) {\\n\\t\\t\\t\\taddDifference(fieldName);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// Return whether there were any differences\\n\\t\\treturn differences.length === 0;\\n\\t};\\n\\t\\n\\t/*\\n\\tRegister and install the built in tiddler field modules\\n\\t*/\\n\\t$tw.modules.define(\\\"$:/boot/tiddlerfields/modified\\\",\\\"tiddlerfield\\\",{\\n\\t\\tname: \\\"modified\\\",\\n\\t\\tparse: $tw.utils.parseDate,\\n\\t\\tstringify: $tw.utils.stringifyDate\\n\\t});\\n\\t$tw.modules.define(\\\"$:/boot/tiddlerfields/created\\\",\\\"tiddlerfield\\\",{\\n\\t\\tname: \\\"created\\\",\\n\\t\\tparse: $tw.utils.parseDate,\\n\\t\\tstringify: $tw.utils.stringifyDate\\n\\t});\\n\\t$tw.modules.define(\\\"$:/boot/tiddlerfields/color\\\",\\\"tiddlerfield\\\",{\\n\\t\\tname: \\\"color\\\",\\n\\t\\teditTag: \\\"input\\\",\\n\\t\\teditType: \\\"color\\\"\\n\\t});\\n\\t$tw.modules.define(\\\"$:/boot/tiddlerfields/tags\\\",\\\"tiddlerfield\\\",{\\n\\t\\tname: \\\"tags\\\",\\n\\t\\tparse: $tw.utils.parseStringArray,\\n\\t\\tstringify: $tw.utils.stringifyList\\n\\t});\\n\\t$tw.modules.define(\\\"$:/boot/tiddlerfields/list\\\",\\\"tiddlerfield\\\",{\\n\\t\\tname: \\\"list\\\",\\n\\t\\tparse: $tw.utils.parseStringArray,\\n\\t\\tstringify: $tw.utils.stringifyList\\n\\t});\\n\\t\\n\\t/////////////////////////// Barebones wiki store\\n\\t\\n\\t/*\\n\\tWiki constructor. State is stored in private members that only a small number of privileged accessor methods have direct access. Methods added via the prototype have to use these accessors and cannot access the state data directly.\\n\\toptions include:\\n\\tenableIndexers - Array of indexer names to enable, or null to use all available indexers\\n\\t*/\\n\\t$tw.Wiki = function(options) {\\n\\t\\toptions = options || {};\\n\\t\\tvar self = this,\\n\\t\\t\\ttiddlers = Object.create(null), // Hashmap of tiddlers\\n\\t\\t\\ttiddlerTitles = null, // Array of tiddler titles\\n\\t\\t\\tgetTiddlerTitles = function() {\\n\\t\\t\\t\\tif(!tiddlerTitles) {\\n\\t\\t\\t\\t\\ttiddlerTitles = Object.keys(tiddlers).sort(function(a,b) {return a.localeCompare(b);});\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn tiddlerTitles;\\n\\t\\t\\t},\\n\\t\\t\\tpluginTiddlers = [], // Array of tiddlers containing registered plugins, ordered by priority\\n\\t\\t\\tpluginInfo = Object.create(null), // Hashmap of parsed plugin content\\n\\t\\t\\tshadowTiddlers = Object.create(null), // Hashmap by title of {source:, tiddler:}\\n\\t\\t\\tshadowTiddlerTitles = null,\\n\\t\\t\\tgetShadowTiddlerTitles = function() {\\n\\t\\t\\t\\tif(!shadowTiddlerTitles) {\\n\\t\\t\\t\\t\\tshadowTiddlerTitles = Object.keys(shadowTiddlers).sort(function(a,b) {return a.localeCompare(b);});\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn shadowTiddlerTitles;\\n\\t\\t\\t},\\n\\t\\t\\tenableIndexers = options.enableIndexers || null,\\n\\t\\t\\tindexers = [],\\n\\t\\t\\tindexersByName = Object.create(null);\\n\\t\\n\\t\\tthis.addIndexer = function(indexer,name) {\\n\\t\\t\\t// Bail if this indexer is not enabled\\n\\t\\t\\tif(enableIndexers && enableIndexers.indexOf(name) === -1) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tindexers.push(indexer);\\n\\t\\t\\tindexersByName[name] = indexer;\\n\\t\\t\\tindexer.init();\\n\\t\\t};\\n\\t\\n\\t\\tthis.getIndexer = function(name) {\\n\\t\\t\\treturn indexersByName[name] || null;\\n\\t\\t};\\n\\t\\n\\t\\t// Add a tiddler to the store\\n\\t\\tthis.addTiddler = function(tiddler) {\\n\\t\\t\\tif(!(tiddler instanceof $tw.Tiddler)) {\\n\\t\\t\\t\\ttiddler = new $tw.Tiddler(tiddler);\\n\\t\\t\\t}\\n\\t\\t\\t// Save the tiddler\\n\\t\\t\\tif(tiddler) {\\n\\t\\t\\t\\tvar title = tiddler.fields.title;\\n\\t\\t\\t\\tif(title) {\\n\\t// Uncomment the following line for detailed logs of all tiddler writes\\n\\t// console.log(\\\"Adding\\\",title,tiddler)\\n\\t\\t\\t\\t\\t// Record the old tiddler state\\n\\t\\t\\t\\t\\tvar updateDescriptor = {\\n\\t\\t\\t\\t\\t\\told: {\\n\\t\\t\\t\\t\\t\\t\\ttiddler: this.getTiddler(title),\\n\\t\\t\\t\\t\\t\\t\\tshadow: this.isShadowTiddler(title),\\n\\t\\t\\t\\t\\t\\t\\texists: this.tiddlerExists(title)\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t// Save the new tiddler\\n\\t\\t\\t\\t\\ttiddlers[title] = tiddler;\\n\\t\\t\\t\\t\\t// Check we've got the title\\n\\t\\t\\t\\t\\ttiddlerTitles = $tw.utils.insertSortedArray(tiddlerTitles || [],title);\\n\\t\\t\\t\\t\\t// Record the new tiddler state\\n\\t\\t\\t\\t\\tupdateDescriptor[\\\"new\\\"] = {\\n\\t\\t\\t\\t\\t\\ttiddler: tiddler,\\n\\t\\t\\t\\t\\t\\tshadow: this.isShadowTiddler(title),\\n\\t\\t\\t\\t\\t\\texists: this.tiddlerExists(title)\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t// Update indexes\\n\\t\\t\\t\\t\\tthis.clearCache(title);\\n\\t\\t\\t\\t\\tthis.clearGlobalCache();\\n\\t\\t\\t\\t\\t$tw.utils.each(indexers,function(indexer) {\\n\\t\\t\\t\\t\\t\\tindexer.update(updateDescriptor);\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t\\t// Queue a change event\\n\\t\\t\\t\\t\\tthis.enqueueTiddlerEvent(title);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\n\\t\\t// Delete a tiddler\\n\\t\\tthis.deleteTiddler = function(title) {\\n\\t// Uncomment the following line for detailed logs of all tiddler deletions\\n\\t// console.log(\\\"Deleting\\\",title)\\n\\t\\t\\tif($tw.utils.hop(tiddlers,title)) {\\n\\t\\t\\t\\t// Record the old tiddler state\\n\\t\\t\\t\\tvar updateDescriptor = {\\n\\t\\t\\t\\t\\told: {\\n\\t\\t\\t\\t\\t\\ttiddler: this.getTiddler(title),\\n\\t\\t\\t\\t\\t\\tshadow: this.isShadowTiddler(title),\\n\\t\\t\\t\\t\\t\\texists: this.tiddlerExists(title)\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// Delete the tiddler\\n\\t\\t\\t\\tdelete tiddlers[title];\\n\\t\\t\\t\\t// Delete it from the list of titles\\n\\t\\t\\t\\tif(tiddlerTitles) {\\n\\t\\t\\t\\t\\tvar index = tiddlerTitles.indexOf(title);\\n\\t\\t\\t\\t\\tif(index !== -1) {\\n\\t\\t\\t\\t\\t\\ttiddlerTitles.splice(index,1);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// Record the new tiddler state\\n\\t\\t\\t\\tupdateDescriptor[\\\"new\\\"] = {\\n\\t\\t\\t\\t\\ttiddler: this.getTiddler(title),\\n\\t\\t\\t\\t\\tshadow: this.isShadowTiddler(title),\\n\\t\\t\\t\\t\\texists: this.tiddlerExists(title)\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// Update indexes\\n\\t\\t\\t\\tthis.clearCache(title);\\n\\t\\t\\t\\tthis.clearGlobalCache();\\n\\t\\t\\t\\t$tw.utils.each(indexers,function(indexer) {\\n\\t\\t\\t\\t\\tindexer.update(updateDescriptor);\\n\\t\\t\\t\\t});\\n\\t\\t\\t\\t// Queue a change event\\n\\t\\t\\t\\tthis.enqueueTiddlerEvent(title,true);\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\n\\t\\t// Get a tiddler from the store\\n\\t\\tthis.getTiddler = function(title) {\\n\\t\\t\\tif(title) {\\n\\t\\t\\t\\tvar t = tiddlers[title];\\n\\t\\t\\t\\tif(t !== undefined) {\\n\\t\\t\\t\\t\\treturn t;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tvar s = shadowTiddlers[title];\\n\\t\\t\\t\\t\\tif(s !== undefined) {\\n\\t\\t\\t\\t\\t\\treturn s.tiddler;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn undefined;\\n\\t\\t};\\n\\t\\n\\t\\t// Get an array of all tiddler titles\\n\\t\\tthis.allTitles = function() {\\n\\t\\t\\treturn getTiddlerTitles().slice(0);\\n\\t\\t};\\n\\t\\n\\t\\t// Iterate through all tiddler titles\\n\\t\\tthis.each = function(callback) {\\n\\t\\t\\tvar titles = getTiddlerTitles(),\\n\\t\\t\\t\\tindex,titlesLength,title;\\n\\t\\t\\tfor(index = 0, titlesLength = titles.length; index < titlesLength; index++) {\\n\\t\\t\\t\\ttitle = titles[index];\\n\\t\\t\\t\\tcallback(tiddlers[title],title);\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\n\\t\\t// Get an array of all shadow tiddler titles\\n\\t\\tthis.allShadowTitles = function() {\\n\\t\\t\\treturn getShadowTiddlerTitles().slice(0);\\n\\t\\t};\\n\\t\\n\\t\\t// Iterate through all shadow tiddler titles\\n\\t\\tthis.eachShadow = function(callback) {\\n\\t\\t\\tvar titles = getShadowTiddlerTitles(),\\n\\t\\t\\t\\tindex,titlesLength,title;\\n\\t\\t\\tfor(index = 0, titlesLength = titles.length; index < titlesLength; index++) {\\n\\t\\t\\t\\ttitle = titles[index];\\n\\t\\t\\t\\tif(tiddlers[title]) {\\n\\t\\t\\t\\t\\tcallback(tiddlers[title],title);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tvar shadowInfo = shadowTiddlers[title];\\n\\t\\t\\t\\t\\tcallback(shadowInfo.tiddler,title);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\n\\t\\t// Iterate through all tiddlers and then the shadows\\n\\t\\tthis.eachTiddlerPlusShadows = function(callback) {\\n\\t\\t\\tvar index,titlesLength,title,\\n\\t\\t\\t\\ttitles = getTiddlerTitles();\\n\\t\\t\\tfor(index = 0, titlesLength = titles.length; index < titlesLength; index++) {\\n\\t\\t\\t\\ttitle = titles[index];\\n\\t\\t\\t\\tcallback(tiddlers[title],title);\\n\\t\\t\\t}\\n\\t\\t\\ttitles = getShadowTiddlerTitles();\\n\\t\\t\\tfor(index = 0, titlesLength = titles.length; index < titlesLength; index++) {\\n\\t\\t\\t\\ttitle = titles[index];\\n\\t\\t\\t\\tif(!tiddlers[title]) {\\n\\t\\t\\t\\t\\tvar shadowInfo = shadowTiddlers[title];\\n\\t\\t\\t\\t\\tcallback(shadowInfo.tiddler,title);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\n\\t\\t// Iterate through all the shadows and then the tiddlers\\n\\t\\tthis.eachShadowPlusTiddlers = function(callback) {\\n\\t\\t\\tvar index,titlesLength,title,\\n\\t\\t\\t\\ttitles = getShadowTiddlerTitles();\\n\\t\\t\\tfor(index = 0, titlesLength = titles.length; index < titlesLength; index++) {\\n\\t\\t\\t\\ttitle = titles[index];\\n\\t\\t\\t\\tif(tiddlers[title]) {\\n\\t\\t\\t\\t\\tcallback(tiddlers[title],title);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tvar shadowInfo = shadowTiddlers[title];\\n\\t\\t\\t\\t\\tcallback(shadowInfo.tiddler,title);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\ttitles = getTiddlerTitles();\\n\\t\\t\\tfor(index = 0, titlesLength = titles.length; index < titlesLength; index++) {\\n\\t\\t\\t\\ttitle = titles[index];\\n\\t\\t\\t\\tif(!shadowTiddlers[title]) {\\n\\t\\t\\t\\t\\tcallback(tiddlers[title],title);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\n\\t\\t// Test for the existence of a tiddler (excludes shadow tiddlers)\\n\\t\\tthis.tiddlerExists = function(title) {\\n\\t\\t\\treturn !!$tw.utils.hop(tiddlers,title);\\n\\t\\t};\\n\\t\\n\\t\\t// Determines if a tiddler is a shadow tiddler, regardless of whether it has been overridden by a real tiddler\\n\\t\\tthis.isShadowTiddler = function(title) {\\n\\t\\t\\treturn $tw.utils.hop(shadowTiddlers,title);\\n\\t\\t};\\n\\t\\n\\t\\tthis.getShadowSource = function(title) {\\n\\t\\t\\tif($tw.utils.hop(shadowTiddlers,title)) {\\n\\t\\t\\t\\treturn shadowTiddlers[title].source;\\n\\t\\t\\t}\\n\\t\\t\\treturn null;\\n\\t\\t};\\n\\t\\n\\t\\t// Get an array of all the currently recognised plugin types\\n\\t\\tthis.getPluginTypes = function() {\\n\\t\\t\\tvar types = [];\\n\\t\\t\\t$tw.utils.each(pluginTiddlers,function(pluginTiddler) {\\n\\t\\t\\t\\tvar pluginType = pluginTiddler.fields[\\\"plugin-type\\\"];\\n\\t\\t\\t\\tif(pluginType && types.indexOf(pluginType) === -1) {\\n\\t\\t\\t\\t\\ttypes.push(pluginType);\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\t\\t\\treturn types;\\n\\t\\t};\\n\\t\\n\\t\\t// Read plugin info for all plugins, or just an array of titles. Returns the number of plugins updated or deleted\\n\\t\\tthis.readPluginInfo = function(titles) {\\n\\t\\t\\tvar results = {\\n\\t\\t\\t\\tmodifiedPlugins: [],\\n\\t\\t\\t\\tdeletedPlugins: []\\n\\t\\t\\t};\\n\\t\\t\\t$tw.utils.each(titles || getTiddlerTitles(),function(title) {\\n\\t\\t\\t\\tvar tiddler = tiddlers[title];\\n\\t\\t\\t\\tif(tiddler) {\\n\\t\\t\\t\\t\\tif(tiddler.fields.type === \\\"application/json\\\" && tiddler.hasField(\\\"plugin-type\\\") && tiddler.fields.text) {\\n\\t\\t\\t\\t\\t\\tpluginInfo[tiddler.fields.title] = $tw.utils.parseJSONSafe(tiddler.fields.text);\\n\\t\\t\\t\\t\\t\\tresults.modifiedPlugins.push(tiddler.fields.title);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tif(pluginInfo[title]) {\\n\\t\\t\\t\\t\\t\\tdelete pluginInfo[title];\\n\\t\\t\\t\\t\\t\\tresults.deletedPlugins.push(title);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\t\\t\\treturn results;\\n\\t\\t};\\n\\t\\n\\t\\t// Get plugin info for a plugin\\n\\t\\tthis.getPluginInfo = function(title) {\\n\\t\\t\\treturn pluginInfo[title];\\n\\t\\t};\\n\\t\\n\\t\\t// Register the plugin tiddlers of a particular type, or null/undefined for any type, optionally restricting registration to an array of tiddler titles. Return the array of titles affected\\n\\t\\tthis.registerPluginTiddlers = function(pluginType,titles) {\\n\\t\\t\\tvar self = this,\\n\\t\\t\\t\\tregisteredTitles = [],\\n\\t\\t\\t\\tcheckTiddler = function(tiddler,title) {\\n\\t\\t\\t\\t\\tif(tiddler && tiddler.fields.type === \\\"application/json\\\" && tiddler.fields[\\\"plugin-type\\\"] && (!pluginType || tiddler.fields[\\\"plugin-type\\\"] === pluginType)) {\\n\\t\\t\\t\\t\\t\\tvar disablingTiddler = self.getTiddler(\\\"$:/config/Plugins/Disabled/\\\" + title);\\n\\t\\t\\t\\t\\t\\tif(title === \\\"$:/core\\\" || !disablingTiddler || (disablingTiddler.fields.text || \\\"\\\").trim() !== \\\"yes\\\") {\\n\\t\\t\\t\\t\\t\\t\\tself.unregisterPluginTiddlers(null,[title]); // Unregister the plugin if it's already registered\\n\\t\\t\\t\\t\\t\\t\\tpluginTiddlers.push(tiddler);\\n\\t\\t\\t\\t\\t\\t\\tregisteredTitles.push(tiddler.fields.title);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t};\\n\\t\\t\\tif(titles) {\\n\\t\\t\\t\\t$tw.utils.each(titles,function(title) {\\n\\t\\t\\t\\t\\tcheckTiddler(self.getTiddler(title),title);\\n\\t\\t\\t\\t});\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tthis.each(function(tiddler,title) {\\n\\t\\t\\t\\t\\tcheckTiddler(tiddler,title);\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\t\\t\\treturn registeredTitles;\\n\\t\\t};\\n\\t\\n\\t\\t// Unregister the plugin tiddlers of a particular type, or null/undefined for any type, optionally restricting unregistering to an array of tiddler titles. Returns an array of the titles affected\\n\\t\\tthis.unregisterPluginTiddlers = function(pluginType,titles) {\\n\\t\\t\\tvar self = this,\\n\\t\\t\\t\\tunregisteredTitles = [];\\n\\t\\t\\t// Remove any previous registered plugins of this type\\n\\t\\t\\tfor(var t=pluginTiddlers.length-1; t>=0; t--) {\\n\\t\\t\\t\\tvar tiddler = pluginTiddlers[t];\\n\\t\\t\\t\\tif(tiddler.fields[\\\"plugin-type\\\"] && (!pluginType || tiddler.fields[\\\"plugin-type\\\"] === pluginType) && (!titles || titles.indexOf(tiddler.fields.title) !== -1)) {\\n\\t\\t\\t\\t\\tunregisteredTitles.push(tiddler.fields.title);\\n\\t\\t\\t\\t\\tpluginTiddlers.splice(t,1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn unregisteredTitles;\\n\\t\\t};\\n\\t\\n\\t\\t// Unpack the currently registered plugins, creating shadow tiddlers for their constituent tiddlers\\n\\t\\tthis.unpackPluginTiddlers = function() {\\n\\t\\t\\tvar self = this;\\n\\t\\t\\t// Sort the plugin titles by the `plugin-priority` field\\n\\t\\t\\tpluginTiddlers.sort(function(a,b) {\\n\\t\\t\\t\\tif(\\\"plugin-priority\\\" in a.fields && \\\"plugin-priority\\\" in b.fields) {\\n\\t\\t\\t\\t\\treturn a.fields[\\\"plugin-priority\\\"] - b.fields[\\\"plugin-priority\\\"];\\n\\t\\t\\t\\t} else if(\\\"plugin-priority\\\" in a.fields) {\\n\\t\\t\\t\\t\\treturn -1;\\n\\t\\t\\t\\t} else if(\\\"plugin-priority\\\" in b.fields) {\\n\\t\\t\\t\\t\\treturn +1;\\n\\t\\t\\t\\t} else if(a.fields.title < b.fields.title) {\\n\\t\\t\\t\\t\\treturn -1;\\n\\t\\t\\t\\t} else if(a.fields.title === b.fields.title) {\\n\\t\\t\\t\\t\\treturn 0;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\treturn +1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\t\\t\\t// Now go through the plugins in ascending order and assign the shadows\\n\\t\\t\\tshadowTiddlers = Object.create(null);\\n\\t\\t\\t$tw.utils.each(pluginTiddlers,function(tiddler) {\\n\\t\\t\\t\\t// Extract the constituent tiddlers\\n\\t\\t\\t\\tif($tw.utils.hop(pluginInfo,tiddler.fields.title)) {\\n\\t\\t\\t\\t\\t$tw.utils.each(pluginInfo[tiddler.fields.title].tiddlers,function(constituentTiddler,constituentTitle) {\\n\\t\\t\\t\\t\\t\\t// Save the tiddler object\\n\\t\\t\\t\\t\\t\\tif(constituentTitle) {\\n\\t\\t\\t\\t\\t\\t\\tshadowTiddlers[constituentTitle] = {\\n\\t\\t\\t\\t\\t\\t\\t\\tsource: tiddler.fields.title,\\n\\t\\t\\t\\t\\t\\t\\t\\ttiddler: new $tw.Tiddler(constituentTiddler,{title: constituentTitle})\\n\\t\\t\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\t\\t\\tshadowTiddlerTitles = null;\\n\\t\\t\\tthis.clearCache(null);\\n\\t\\t\\tthis.clearGlobalCache();\\n\\t\\t\\t$tw.utils.each(indexers,function(indexer) {\\n\\t\\t\\t\\tindexer.rebuild();\\n\\t\\t\\t});\\n\\t\\t};\\n\\t\\n\\t\\tif(this.addIndexersToWiki) {\\n\\t\\t\\tthis.addIndexersToWiki();\\n\\t\\t}\\n\\t};\\n\\t\\n\\t// Dummy methods that will be filled in after boot\\n\\t$tw.Wiki.prototype.clearCache =\\n\\t$tw.Wiki.prototype.clearGlobalCache =\\n\\t$tw.Wiki.prototype.enqueueTiddlerEvent = function() {};\\n\\t\\n\\t// Add an array of tiddlers\\n\\t$tw.Wiki.prototype.addTiddlers = function(tiddlers) {\\n\\t\\tfor(var t=0; t<tiddlers.length; t++) {\\n\\t\\t\\tthis.addTiddler(tiddlers[t]);\\n\\t\\t}\\n\\t};\\n\\t\\n\\t/*\\n\\tDefine all modules stored in ordinary tiddlers\\n\\t*/\\n\\t$tw.Wiki.prototype.defineTiddlerModules = function() {\\n\\t\\tthis.each(function(tiddler,title) {\\n\\t\\t\\tif(tiddler.hasField(\\\"module-type\\\")) {\\n\\t\\t\\t\\tswitch(tiddler.fields.type) {\\n\\t\\t\\t\\t\\tcase \\\"application/javascript\\\":\\n\\t\\t\\t\\t\\t\\t// We only define modules that haven't already been defined, because in the browser modules in system tiddlers are defined in inline script\\n\\t\\t\\t\\t\\t\\tif(!$tw.utils.hop($tw.modules.titles,tiddler.fields.title)) {\\n\\t\\t\\t\\t\\t\\t\\t$tw.modules.define(tiddler.fields.title,tiddler.fields[\\\"module-type\\\"],tiddler.fields.text);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tcase \\\"application/json\\\":\\n\\t\\t\\t\\t\\t\\t$tw.modules.define(tiddler.fields.title,tiddler.fields[\\\"module-type\\\"],$tw.utils.parseJSONSafe(tiddler.fields.text));\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tcase \\\"application/x-tiddler-dictionary\\\":\\n\\t\\t\\t\\t\\t\\t$tw.modules.define(tiddler.fields.title,tiddler.fields[\\\"module-type\\\"],$tw.utils.parseFields(tiddler.fields.text));\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t});\\n\\t};\\n\\t\\n\\t/*\\n\\tRegister all the module tiddlers that have a module type\\n\\t*/\\n\\t$tw.Wiki.prototype.defineShadowModules = function() {\\n\\t\\tvar self = this;\\n\\t\\tthis.eachShadow(function(tiddler,title) {\\n\\t\\t\\t// Don't define the module if it is overidden by an ordinary tiddler\\n\\t\\t\\tif(!self.tiddlerExists(title) && tiddler.hasField(\\\"module-type\\\")) {\\n\\t\\t\\t\\t// Define the module\\n\\t\\t\\t\\t$tw.modules.define(tiddler.fields.title,tiddler.fields[\\\"module-type\\\"],tiddler.fields.text);\\n\\t\\t\\t}\\n\\t\\t});\\n\\t};\\n\\t\\n\\t/*\\n\\tEnable safe mode by deleting any tiddlers that override a shadow tiddler\\n\\t*/\\n\\t$tw.Wiki.prototype.processSafeMode = function() {\\n\\t\\tvar self = this,\\n\\t\\t\\toverrides = [];\\n\\t\\t// Find the overriding tiddlers\\n\\t\\tthis.each(function(tiddler,title) {\\n\\t\\t\\tif(self.isShadowTiddler(title)) {\\n\\t\\t\\t\\tconsole.log(title);\\n\\t\\t\\t\\toverrides.push(title);\\n\\t\\t\\t}\\n\\t\\t});\\n\\t\\t// Assemble a report tiddler\\n\\t\\tvar titleReportTiddler = \\\"TiddlyWiki Safe Mode\\\",\\n\\t\\t\\treport = [];\\n\\t\\treport.push(\\\"TiddlyWiki has been started in [[safe mode|https://tiddlywiki.com/static/SafeMode.html]]. All plugins are temporarily disabled. Most customisations have been disabled by renaming the following tiddlers:\\\")\\n\\t\\t// Delete the overrides\\n\\t\\toverrides.forEach(function(title) {\\n\\t\\t\\tvar tiddler = self.getTiddler(title),\\n\\t\\t\\t\\tnewTitle = \\\"SAFE: \\\" + title;\\n\\t\\t\\tself.deleteTiddler(title);\\n\\t\\t\\tself.addTiddler(new $tw.Tiddler(tiddler, {title: newTitle}));\\n\\t\\t\\treport.push(\\\"* [[\\\" + title + \\\"|\\\" + newTitle + \\\"]]\\\");\\n\\t\\t});\\n\\t\\treport.push()\\n\\t\\tthis.addTiddler(new $tw.Tiddler({title: titleReportTiddler, text: report.join(\\\"\\\\n\\\\n\\\")}));\\n\\t\\t// Set $:/DefaultTiddlers to point to our report\\n\\t\\tthis.addTiddler(new $tw.Tiddler({title: \\\"$:/DefaultTiddlers\\\", text: \\\"[[\\\" + titleReportTiddler + \\\"]]\\\"}));\\n\\t};\\n\\t\\n\\t/*\\n\\tExtracts tiddlers from a typed block of text, specifying default field values\\n\\t*/\\n\\t$tw.Wiki.prototype.deserializeTiddlers = function(type,text,srcFields,options) {\\n\\t\\tsrcFields = srcFields || Object.create(null);\\n\\t\\toptions = options || {};\\n\\t\\tvar deserializer = $tw.Wiki.tiddlerDeserializerModules[options.deserializer],\\n\\t\\t\\tfields = Object.create(null);\\n\\t\\tif(!deserializer) {\\n\\t\\t\\tdeserializer = $tw.Wiki.tiddlerDeserializerModules[type];\\n\\t\\t}\\n\\t\\tif(!deserializer && $tw.utils.getFileExtensionInfo(type)) {\\n\\t\\t\\t// If we didn't find the serializer, try converting it from an extension to a content type\\n\\t\\t\\ttype = $tw.utils.getFileExtensionInfo(type).type;\\n\\t\\t\\tdeserializer = $tw.Wiki.tiddlerDeserializerModules[type];\\n\\t\\t}\\n\\t\\tif(!deserializer && $tw.config.contentTypeInfo[type]) {\\n\\t\\t\\t// see if this type has a different deserializer registered with it\\n\\t\\t\\ttype = $tw.config.contentTypeInfo[type].deserializerType;\\n\\t\\t\\tdeserializer = $tw.Wiki.tiddlerDeserializerModules[type];\\n\\t\\t}\\n\\t\\tif(!deserializer) {\\n\\t\\t\\t// If we still don't have a deserializer, treat it as plain text\\n\\t\\t\\tdeserializer = $tw.Wiki.tiddlerDeserializerModules[\\\"text/plain\\\"];\\n\\t\\t}\\n\\t\\tfor(var f in srcFields) {\\n\\t\\t\\tfields[f] = srcFields[f];\\n\\t\\t}\\n\\t\\tif(deserializer) {\\n\\t\\t\\treturn deserializer.call(this,text,fields,type);\\n\\t\\t} else {\\n\\t\\t\\t// Return a raw tiddler for unknown types\\n\\t\\t\\tfields.text = text;\\n\\t\\t\\treturn [fields];\\n\\t\\t}\\n\\t};\\n\\t\\n\\t/*\\n\\tRegister the built in tiddler deserializer modules\\n\\t*/\\n\\tvar deserializeHeaderComment = function(text,fields) {\\n\\t\\t\\tvar headerCommentRegExp = new RegExp($tw.config.jsModuleHeaderRegExpString,\\\"mg\\\"),\\n\\t\\t\\t\\tmatch = headerCommentRegExp.exec(text);\\n\\t\\t\\tfields.text = text;\\n\\t\\t\\tif(match) {\\n\\t\\t\\t\\tfields = $tw.utils.parseFields(match[1].split(/\\\\r?\\\\n\\\\r?\\\\n/mg)[0],fields);\\n\\t\\t\\t}\\n\\t\\t\\treturn [fields];\\n\\t\\t};\\n\\t$tw.modules.define(\\\"$:/boot/tiddlerdeserializer/js\\\",\\\"tiddlerdeserializer\\\",{\\n\\t\\t\\\"application/javascript\\\": deserializeHeaderComment\\n\\t});\\n\\t$tw.modules.define(\\\"$:/boot/tiddlerdeserializer/css\\\",\\\"tiddlerdeserializer\\\",{\\n\\t\\t\\\"text/css\\\": deserializeHeaderComment\\n\\t});\\n\\t$tw.modules.define(\\\"$:/boot/tiddlerdeserializer/tid\\\",\\\"tiddlerdeserializer\\\",{\\n\\t\\t\\\"application/x-tiddler\\\": function(text,fields) {\\n\\t\\t\\tvar split = text.split(/\\\\r?\\\\n\\\\r?\\\\n/mg);\\n\\t\\t\\tif(split.length >= 1) {\\n\\t\\t\\t\\tfields = $tw.utils.parseFields(split[0],fields);\\n\\t\\t\\t}\\n\\t\\t\\tif(split.length >= 2) {\\n\\t\\t\\t\\tfields.text = split.slice(1).join(\\\"\\\\n\\\\n\\\");\\n\\t\\t\\t}\\n\\t\\t\\treturn [fields];\\n\\t\\t}\\n\\t});\\n\\t$tw.modules.define(\\\"$:/boot/tiddlerdeserializer/tids\\\",\\\"tiddlerdeserializer\\\",{\\n\\t\\t\\\"application/x-tiddlers\\\": function(text,fields) {\\n\\t\\t\\tvar titles = [],\\n\\t\\t\\t\\ttiddlers = [],\\n\\t\\t\\t\\tmatch = /\\\\r?\\\\n\\\\r?\\\\n/mg.exec(text);\\n\\t\\t\\tif(match) {\\n\\t\\t\\t\\tfields = $tw.utils.parseFields(text.substr(0,match.index),fields);\\n\\t\\t\\t\\tvar lines = text.substr(match.index + match[0].length).split(/\\\\r?\\\\n/mg);\\n\\t\\t\\t\\tfor(var t=0; t<lines.length; t++) {\\n\\t\\t\\t\\t\\tvar line = lines[t];\\n\\t\\t\\t\\t\\tif(line.charAt(0) !== \\\"#\\\") {\\n\\t\\t\\t\\t\\t\\tvar colonPos= line.indexOf(\\\":\\\");\\n\\t\\t\\t\\t\\t\\tif(colonPos !== -1) {\\n\\t\\t\\t\\t\\t\\t\\tvar tiddler = $tw.utils.extend(Object.create(null),fields);\\n\\t\\t\\t\\t\\t\\t\\ttiddler.title = (tiddler.title || \\\"\\\") + line.substr(0,colonPos).trim();\\n\\t\\t\\t\\t\\t\\t\\tif(titles.indexOf(tiddler.title) !== -1) {\\n\\t\\t\\t\\t\\t\\t\\t\\tconsole.log(\\\"Warning: .multids file contains multiple definitions for \\\" + tiddler.title);\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\ttitles.push(tiddler.title);\\n\\t\\t\\t\\t\\t\\t\\ttiddler.text = line.substr(colonPos + 2).trim();\\n\\t\\t\\t\\t\\t\\t\\ttiddlers.push(tiddler);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn tiddlers;\\n\\t\\t}\\n\\t});\\n\\t$tw.modules.define(\\\"$:/boot/tiddlerdeserializer/txt\\\",\\\"tiddlerdeserializer\\\",{\\n\\t\\t\\\"text/plain\\\": function(text,fields,type) {\\n\\t\\t\\tfields.text = text;\\n\\t\\t\\tfields.type = type || \\\"text/plain\\\";\\n\\t\\t\\treturn [fields];\\n\\t\\t}\\n\\t});\\n\\t$tw.modules.define(\\\"$:/boot/tiddlerdeserializer/html\\\",\\\"tiddlerdeserializer\\\",{\\n\\t\\t\\\"text/html\\\": function(text,fields) {\\n\\t\\t\\tfields.text = text;\\n\\t\\t\\tfields.type = \\\"text/html\\\";\\n\\t\\t\\treturn [fields];\\n\\t\\t}\\n\\t});\\n\\t$tw.modules.define(\\\"$:/boot/tiddlerdeserializer/json\\\",\\\"tiddlerdeserializer\\\",{\\n\\t\\t\\\"application/json\\\": function(text,fields) {\\n\\t\\t\\tvar isTiddlerValid = function(data) {\\n\\t\\t\\t\\t\\t// Not valid if it's not an object with a title property\\n\\t\\t\\t\\t\\tif(typeof(data) !== \\\"object\\\" || !$tw.utils.hop(data,\\\"title\\\")) {\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tfor(var f in data) {\\n\\t\\t\\t\\t\\t\\tif($tw.utils.hop(data,f)) {\\n\\t\\t\\t\\t\\t\\t\\t// Check field name doesn't contain control characters\\n\\t\\t\\t\\t\\t\\t\\tif(typeof(data[f]) !== \\\"string\\\" || /[\\\\x00-\\\\x1F]/.test(f)) {\\n\\t\\t\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\tisTiddlerArrayValid = function(data) {\\n\\t\\t\\t\\t\\tfor(var t=0; t<data.length; t++) {\\n\\t\\t\\t\\t\\t\\tif(!isTiddlerValid(data[t])) {\\n\\t\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\tdata = $tw.utils.parseJSONSafe(text);\\n\\t\\t\\tif($tw.utils.isArray(data) && isTiddlerArrayValid(data)) {\\n\\t\\t\\t\\tif($tw.CSE.launched) {\\n\\t\\t\\t\\t\\tfor(var t = 0; t < data.length; t++) {\\n\\t\\t\\t\\t\\t\\tif($tw.utils.hop(data[t], \\\"encrypted\\\")) {\\n\\t\\t\\t\\t\\t\\t\\tvar decryptedFields = $tw.CSE.decryptFields(data[t])\\n\\t\\t\\t\\t\\t\\t\\tif(decryptedFields) {\\n\\t\\t\\t\\t\\t\\t\\t\\tif($tw.utils.hop(data[t], \\\"revision\\\") && $tw.utils.hop(data[t], \\\"bag\\\"))\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tdecryptedFields = $tw.utils.extend(decryptedFields, {\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\trevision: data[t].revision,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tbag: data[t].bag\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t})\\n\\t\\t\\t\\t\\t\\t\\t\\tdata[t] = decryptedFields\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn data;\\n\\t\\t\\t} else if(isTiddlerValid(data)) {\\n\\t\\t\\t\\treturn [data];\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// Plain JSON file\\n\\t\\t\\t\\tfields.text = text;\\n\\t\\t\\t\\tfields.type = \\\"application/json\\\";\\n\\t\\t\\t\\treturn [fields];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t});\\n\\t\\n\\t/////////////////////////// Browser definitions\\n\\t\\n\\tif($tw.browser && !$tw.node) {\\n\\t\\n\\t/*\\n\\tDecrypt any tiddlers stored within the element with the ID \\\"encryptedArea\\\". The function is asynchronous to allow the user to be prompted for a password\\n\\t\\tcallback: function to be called the decryption is complete\\n\\t*/\\n\\t$tw.boot.decryptEncryptedTiddlers = function(callback) {\\n\\t\\tvar encryptedArea = document.getElementById(\\\"encryptedStoreArea\\\");\\n\\t\\tif(encryptedArea) {\\n\\t\\t\\tvar encryptedText = encryptedArea.innerHTML,\\n\\t\\t\\t\\tprompt = \\\"Enter a password to decrypt this TiddlyWiki\\\";\\n\\t\\t\\t// Prompt for the password\\n\\t\\t\\tif($tw.utils.hop($tw.boot,\\\"encryptionPrompts\\\")) {\\n\\t\\t\\t\\tprompt = $tw.boot.encryptionPrompts.decrypt;\\n\\t\\t\\t}\\n\\t\\t\\t$tw.passwordPrompt.createPrompt({\\n\\t\\t\\t\\tserviceName: prompt,\\n\\t\\t\\t\\tnoUserName: true,\\n\\t\\t\\t\\tsubmitText: \\\"Decrypt\\\",\\n\\t\\t\\t\\tcallback: function(data) {\\n\\t\\t\\t\\t\\t// Attempt to decrypt the tiddlers\\n\\t\\t\\t\\t\\t$tw.crypto.setPassword(data.password);\\n\\t\\t\\t\\t\\tvar decryptedText = $tw.crypto.decrypt(encryptedText);\\n\\t\\t\\t\\t\\tif(decryptedText) {\\n\\t\\t\\t\\t\\t\\tvar json = $tw.utils.parseJSONSafe(decryptedText);\\n\\t\\t\\t\\t\\t\\tfor(var title in json) {\\n\\t\\t\\t\\t\\t\\t\\t$tw.preloadTiddler(json[title]);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t// Call the callback\\n\\t\\t\\t\\t\\t\\tcallback();\\n\\t\\t\\t\\t\\t\\t// Exit and remove the password prompt\\n\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t// We didn't decrypt everything, so continue to prompt for password\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\t\\t} else {\\n\\t\\t\\tvar CSEncryptedMetaArea = document.getElementById(\\\"CSEncryptedMetaArea\\\");\\n\\t\\t\\tif(CSEncryptedMetaArea){\\n\\t\\t\\t\\tvar CSEncryptedText = CSEncryptedMetaArea.innerHTML,\\n\\t\\t\\t\\t\\tprompt = \\\"CSE: Enter a password to decrypt this TiddlyWiki\\\";\\n\\t\\t\\t\\tvar CSEncryptedInfo = JSON.parse(CSEncryptedText)\\n\\t\\n\\t\\t\\t\\tconsole.log(CSEncryptedMetaArea)\\n\\t\\t\\t\\tvar pwdCallback = function (data) {\\n\\t\\t\\t\\t\\t$tw.CSE.setPassword(data.password);\\n\\t\\t\\t\\t\\t$tw.CSE.launched = true\\n\\t\\t\\t\\t\\tcallback();\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(CSEncryptedInfo && CSEncryptedInfo.config && CSEncryptedInfo.config.RmbPwd === \\\"yes\\\" && window.localStorage.getItem(\\\"tw5-cse-pwd\\\")){\\n\\t\\t\\t\\t\\tpwdCallback({password:window.localStorage.getItem(\\\"tw5-cse-pwd\\\")})\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t$tw.passwordPrompt.createPrompt({\\n\\t\\t\\t\\t\\t\\tserviceName: prompt,\\n\\t\\t\\t\\t\\t\\tnoUserName: true,\\n\\t\\t\\t\\t\\t\\tsubmitText: \\\"Decrypt\\\",\\n\\t\\t\\t\\t\\t\\tcallback: pwdCallback\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t// Just invoke the callback straight away if there weren't any encrypted tiddlers\\n\\t\\t\\tcallback();\\n\\t\\t}\\n\\t\\t}\\n\\t};\\n\\t\\n\\t/*\\n\\tRegister a deserializer that can extract tiddlers from the DOM\\n\\t*/\\n\\t$tw.modules.define(\\\"$:/boot/tiddlerdeserializer/dom\\\",\\\"tiddlerdeserializer\\\",{\\n\\t\\t\\\"(DOM)\\\": function(node) {\\n\\t\\t\\tvar extractTextTiddlers = function(node) {\\n\\t\\t\\t\\t\\tvar e = node.firstChild;\\n\\t\\t\\t\\t\\twhile(e && e.nodeName.toLowerCase() !== \\\"pre\\\") {\\n\\t\\t\\t\\t\\t\\te = e.nextSibling;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tvar title = node.getAttribute ? node.getAttribute(\\\"title\\\") : null;\\n\\t\\t\\t\\t\\tif(e && title) {\\n\\t\\t\\t\\t\\t\\tvar attrs = node.attributes,\\n\\t\\t\\t\\t\\t\\t\\ttiddler = {\\n\\t\\t\\t\\t\\t\\t\\t\\ttext: $tw.utils.htmlDecode(e.innerHTML)\\n\\t\\t\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t\\t\\tfor(var i=attrs.length-1; i >= 0; i--) {\\n\\t\\t\\t\\t\\t\\t\\ttiddler[attrs[i].name] = attrs[i].value;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\treturn [tiddler];\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\treturn null;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\textractModuleTiddlers = function(node) {\\n\\t\\t\\t\\t\\tif(node.hasAttribute && node.hasAttribute(\\\"data-tiddler-title\\\")) {\\n\\t\\t\\t\\t\\t\\tvar text = node.innerHTML,\\n\\t\\t\\t\\t\\t\\t\\ts = text.indexOf(\\\"{\\\"),\\n\\t\\t\\t\\t\\t\\t\\te = text.lastIndexOf(\\\"}\\\");\\n\\t\\t\\t\\t\\t\\tif(node.hasAttribute(\\\"data-module\\\") && s !== -1 && e !== -1) {\\n\\t\\t\\t\\t\\t\\t\\ttext = text.substring(s+1,e);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tvar fields = {text: text},\\n\\t\\t\\t\\t\\t\\t\\tattributes = node.attributes;\\n\\t\\t\\t\\t\\t\\tfor(var a=0; a<attributes.length; a++) {\\n\\t\\t\\t\\t\\t\\t\\tif(attributes[a].nodeName.substr(0,13) === \\\"data-tiddler-\\\") {\\n\\t\\t\\t\\t\\t\\t\\t\\tfields[attributes[a].nodeName.substr(13)] = attributes[a].value;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\treturn [fields];\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\treturn null;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\tt,result = [];\\n\\t\\t\\tif(node) {\\n\\t\\t\\t\\tvar type = (node.getAttribute && node.getAttribute(\\\"type\\\")) || null;\\n\\t\\t\\t\\tif(type) {\\n\\t\\t\\t\\t\\t// A new-style container with an explicit deserialization type\\n\\t\\t\\t\\t\\tresult = $tw.wiki.deserializeTiddlers(type,node.textContent);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t// An old-style container of classic DIV-based tiddlers\\n\\t\\t\\t\\t\\tfor(t = 0; t < node.childNodes.length; t++) {\\n\\t\\t\\t\\t\\t\\tvar childNode = node.childNodes[t],\\n\\t\\t\\t\\t\\t\\t\\ttiddlers = extractTextTiddlers(childNode);\\n\\t\\t\\t\\t\\t\\ttiddlers = tiddlers || extractModuleTiddlers(childNode);\\n\\t\\t\\t\\t\\t\\tif(tiddlers) {\\n\\t\\t\\t\\t\\t\\t\\tresult.push.apply(result,tiddlers);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t});\\n\\t\\n\\t$tw.loadTiddlersBrowser = function() {\\n\\t\\t// In the browser, we load tiddlers from certain elements\\n\\t\\tvar containerSelectors = [\\n\\t\\t\\t// IDs for old-style v5.1.x tiddler stores\\n\\t\\t\\t\\\"#libraryModules\\\",\\n\\t\\t\\t\\\"#modules\\\",\\n\\t\\t\\t\\\"#bootKernelPrefix\\\",\\n\\t\\t\\t\\\"#bootKernel\\\",\\n\\t\\t\\t\\\"#styleArea\\\",\\n\\t\\t\\t\\\"#storeArea\\\",\\n\\t\\t\\t\\\"#systemArea\\\",\\n\\t\\t\\t// Classes for new-style v5.2.x JSON tiddler stores\\n\\t\\t\\t\\\"script.tiddlywiki-tiddler-store\\\"\\n\\t\\t];\\n\\t\\tfor(var t=0; t<containerSelectors.length; t++) {\\n\\t\\t\\tvar nodes = document.querySelectorAll(containerSelectors[t]);\\n\\t\\t\\tfor(var n=0; n<nodes.length; n++) {\\n\\t\\t\\t\\t$tw.wiki.addTiddlers($tw.wiki.deserializeTiddlers(\\\"(DOM)\\\",nodes[n]));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\t\\n\\t} else {\\n\\t\\n\\t/////////////////////////// Server definitions\\n\\t\\n\\t/*\\n\\tGet any encrypted tiddlers\\n\\t*/\\n\\t$tw.boot.decryptEncryptedTiddlers = function(callback) {\\n\\t\\t// Storing encrypted tiddlers on the server isn't supported yet\\n\\t\\tcallback();\\n\\t};\\n\\t\\n\\t} // End of if($tw.browser && !$tw.node)\\n\\t\\n\\t/////////////////////////// Node definitions\\n\\t\\n\\tif($tw.node) {\\n\\t\\n\\t/*\\n\\tLoad the tiddlers contained in a particular file (and optionally extract fields from the accompanying .meta file) returned as {filepath:,type:,tiddlers:[],hasMetaFile:}\\n\\t*/\\n\\t$tw.loadTiddlersFromFile = function(filepath,fields) {\\n\\t\\tvar ext = path.extname(filepath),\\n\\t\\t\\textensionInfo = $tw.utils.getFileExtensionInfo(ext),\\n\\t\\t\\ttype = extensionInfo ? extensionInfo.type : null,\\n\\t\\t\\ttypeInfo = type ? $tw.config.contentTypeInfo[type] : null,\\n\\t\\t\\tdata = fs.readFileSync(filepath,typeInfo ? typeInfo.encoding : \\\"utf8\\\"),\\n\\t\\t\\ttiddlers = $tw.wiki.deserializeTiddlers(ext,data,fields),\\n\\t\\t\\tmetadata = $tw.loadMetadataForFile(filepath);\\n\\t\\tif(metadata) {\\n\\t\\t\\tif(type === \\\"application/json\\\") {\\n\\t\\t\\t\\ttiddlers = [{text: data, type: \\\"application/json\\\"}];\\n\\t\\t\\t}\\n\\t\\t\\ttiddlers = [$tw.utils.extend({},tiddlers[0],metadata)];\\n\\t\\t}\\n\\t\\treturn {filepath: filepath, type: type, tiddlers: tiddlers, hasMetaFile: !!metadata};\\n\\t};\\n\\t\\n\\t/*\\n\\tLoad the metadata fields in the .meta file corresponding to a particular file\\n\\t*/\\n\\t$tw.loadMetadataForFile = function(filepath) {\\n\\t\\tvar metafilename = filepath + \\\".meta\\\";\\n\\t\\tif(fs.existsSync(metafilename)) {\\n\\t\\t\\treturn $tw.utils.parseFields(fs.readFileSync(metafilename,\\\"utf8\\\") || \\\"\\\");\\n\\t\\t} else {\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\t};\\n\\t\\n\\t/*\\n\\tA default set of files for TiddlyWiki to ignore during load.\\n\\tThis matches what NPM ignores, and adds \\\"*.meta\\\" to ignore tiddler\\n\\tmetadata files.\\n\\t*/\\n\\t$tw.boot.excludeRegExp = /^\\\\.DS_Store$|^.*\\\\.meta$|^\\\\..*\\\\.swp$|^\\\\._.*$|^\\\\.git$|^\\\\.github$|^\\\\.vscode$|^\\\\.hg$|^\\\\.lock-wscript$|^\\\\.svn$|^\\\\.wafpickle-.*$|^CVS$|^npm-debug\\\\.log$/;\\n\\t\\n\\t/*\\n\\tLoad all the tiddlers recursively from a directory, including honouring `tiddlywiki.files` files for drawing in external files. Returns an array of {filepath:,type:,tiddlers: [{..fields...}],hasMetaFile:}. Note that no file information is returned for externally loaded tiddlers, just the `tiddlers` property.\\n\\t*/\\n\\t$tw.loadTiddlersFromPath = function(filepath,excludeRegExp) {\\n\\t\\texcludeRegExp = excludeRegExp || $tw.boot.excludeRegExp;\\n\\t\\tvar tiddlers = [];\\n\\t\\tif(fs.existsSync(filepath)) {\\n\\t\\t\\tvar stat = fs.statSync(filepath);\\n\\t\\t\\tif(stat.isDirectory()) {\\n\\t\\t\\t\\tvar files = fs.readdirSync(filepath);\\n\\t\\t\\t\\t// Look for a tiddlywiki.files file\\n\\t\\t\\t\\tif(files.indexOf(\\\"tiddlywiki.files\\\") !== -1) {\\n\\t\\t\\t\\t\\tArray.prototype.push.apply(tiddlers,$tw.loadTiddlersFromSpecification(filepath,excludeRegExp));\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t// If not, read all the files in the directory\\n\\t\\t\\t\\t\\t$tw.utils.each(files,function(file) {\\n\\t\\t\\t\\t\\t\\tif(!excludeRegExp.test(file) && file !== \\\"plugin.info\\\") {\\n\\t\\t\\t\\t\\t\\t\\ttiddlers.push.apply(tiddlers,$tw.loadTiddlersFromPath(filepath + path.sep + file,excludeRegExp));\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else if(stat.isFile()) {\\n\\t\\t\\t\\ttiddlers.push($tw.loadTiddlersFromFile(filepath,{title: filepath}));\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn tiddlers;\\n\\t};\\n\\t\\n\\t/*\\n\\tLoad all the tiddlers defined by a `tiddlywiki.files` specification file\\n\\tfilepath: pathname of the directory containing the specification file\\n\\t*/\\n\\t$tw.loadTiddlersFromSpecification = function(filepath,excludeRegExp) {\\n\\t\\tvar tiddlers = [];\\n\\t\\t// Read the specification\\n\\t\\tvar filesInfo = $tw.utils.parseJSONSafe(fs.readFileSync(filepath + path.sep + \\\"tiddlywiki.files\\\",\\\"utf8\\\"));\\n\\t\\t// Helper to process a file\\n\\t\\tvar processFile = function(filename,isTiddlerFile,fields,isEditableFile,rootPath) {\\n\\t\\t\\tvar extInfo = $tw.config.fileExtensionInfo[path.extname(filename)],\\n\\t\\t\\t\\ttype = (extInfo || {}).type || fields.type || \\\"text/plain\\\",\\n\\t\\t\\t\\ttypeInfo = $tw.config.contentTypeInfo[type] || {},\\n\\t\\t\\t\\tpathname = path.resolve(filepath,filename),\\n\\t\\t\\t\\ttext = fs.readFileSync(pathname,typeInfo.encoding || \\\"utf8\\\"),\\n\\t\\t\\t\\tmetadata = $tw.loadMetadataForFile(pathname) || {},\\n\\t\\t\\t\\tfileTiddlers;\\n\\t\\t\\tif(isTiddlerFile) {\\n\\t\\t\\t\\tfileTiddlers = $tw.wiki.deserializeTiddlers(path.extname(pathname),text,metadata) || [];\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tfileTiddlers =  [$tw.utils.extend({text: text},metadata)];\\n\\t\\t\\t}\\n\\t\\t\\tvar combinedFields = $tw.utils.extend({},fields,metadata);\\n\\t\\t\\t$tw.utils.each(fileTiddlers,function(tiddler) {\\n\\t\\t\\t\\t$tw.utils.each(combinedFields,function(fieldInfo,name) {\\n\\t\\t\\t\\t\\tif(typeof fieldInfo === \\\"string\\\" || $tw.utils.isArray(fieldInfo)) {\\n\\t\\t\\t\\t\\t\\ttiddler[name] = fieldInfo;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tvar value = tiddler[name];\\n\\t\\t\\t\\t\\t\\tswitch(fieldInfo.source) {\\n\\t\\t\\t\\t\\t\\t\\tcase \\\"subdirectories\\\":\\n\\t\\t\\t\\t\\t\\t\\t\\tvalue = path.relative(rootPath, filename).split(path.sep).slice(0, -1);\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\tcase \\\"filepath\\\":\\n\\t\\t\\t\\t\\t\\t\\t\\tvalue = path.relative(rootPath, filename).split(path.sep).join('/');\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\tcase \\\"filename\\\":\\n\\t\\t\\t\\t\\t\\t\\t\\tvalue = path.basename(filename);\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\tcase \\\"filename-uri-decoded\\\":\\n\\t\\t\\t\\t\\t\\t\\t\\tvalue = $tw.utils.decodeURIComponentSafe(path.basename(filename));\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\tcase \\\"basename\\\":\\n\\t\\t\\t\\t\\t\\t\\t\\tvalue = path.basename(filename,path.extname(filename));\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\tcase \\\"basename-uri-decoded\\\":\\n\\t\\t\\t\\t\\t\\t\\t\\tvalue = $tw.utils.decodeURIComponentSafe(path.basename(filename,path.extname(filename)));\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\tcase \\\"extname\\\":\\n\\t\\t\\t\\t\\t\\t\\t\\tvalue = path.extname(filename);\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\tcase \\\"created\\\":\\n\\t\\t\\t\\t\\t\\t\\t\\tvalue = new Date(fs.statSync(pathname).birthtime);\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\tcase \\\"modified\\\":\\n\\t\\t\\t\\t\\t\\t\\t\\tvalue = new Date(fs.statSync(pathname).mtime);\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif(fieldInfo.prefix) {\\n\\t\\t\\t\\t\\t\\t\\tvalue = fieldInfo.prefix + value;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif(fieldInfo.suffix) {\\n\\t\\t\\t\\t\\t\\t\\tvalue = value + fieldInfo.suffix;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\ttiddler[name] = value;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t});\\n\\t\\t\\t});\\n\\t\\t\\tif(isEditableFile) {\\n\\t\\t\\t\\ttiddlers.push({filepath: pathname, hasMetaFile: !!metadata && !isTiddlerFile, isEditableFile: true, tiddlers: fileTiddlers});\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ttiddlers.push({tiddlers: fileTiddlers});\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\t// Helper to recursively search subdirectories\\n\\t\\tvar getAllFiles = function(dirPath, recurse, arrayOfFiles) {\\n\\t\\t\\trecurse = recurse || false;\\n\\t\\t\\tarrayOfFiles = arrayOfFiles || [];\\n\\t\\t\\tvar files = fs.readdirSync(dirPath);\\n\\t\\t\\tfiles.forEach(function(file) {\\n\\t\\t\\t\\tif(recurse && fs.statSync(dirPath + path.sep + file).isDirectory()) {\\n\\t\\t\\t\\t\\tarrayOfFiles = getAllFiles(dirPath + path.sep + file, recurse, arrayOfFiles);\\n\\t\\t\\t\\t} else if(fs.statSync(dirPath + path.sep + file).isFile()){\\n\\t\\t\\t\\t\\tarrayOfFiles.push(path.join(dirPath, path.sep, file));\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\t\\t\\treturn arrayOfFiles;\\n\\t\\t}\\n\\t\\t// Process the listed tiddlers\\n\\t\\t$tw.utils.each(filesInfo.tiddlers,function(tidInfo) {\\n\\t\\t\\tif(tidInfo.prefix && tidInfo.suffix) {\\n\\t\\t\\t\\ttidInfo.fields.text = {prefix: tidInfo.prefix,suffix: tidInfo.suffix};\\n\\t\\t\\t} else if(tidInfo.prefix) {\\n\\t\\t\\t\\ttidInfo.fields.text = {prefix: tidInfo.prefix};\\n\\t\\t\\t} else if(tidInfo.suffix) {\\n\\t\\t\\t\\ttidInfo.fields.text = {suffix: tidInfo.suffix};\\n\\t\\t\\t}\\n\\t\\t\\tprocessFile(tidInfo.file,tidInfo.isTiddlerFile,tidInfo.fields);\\n\\t\\t});\\n\\t\\t// Process any listed directories\\n\\t\\t$tw.utils.each(filesInfo.directories,function(dirSpec) {\\n\\t\\t\\t// Read literal directories directly\\n\\t\\t\\tif(typeof dirSpec === \\\"string\\\") {\\n\\t\\t\\t\\tvar pathname = path.resolve(filepath,dirSpec);\\n\\t\\t\\t\\tif(fs.existsSync(pathname) && fs.statSync(pathname).isDirectory()) {\\n\\t\\t\\t\\t\\ttiddlers.push.apply(tiddlers,$tw.loadTiddlersFromPath(pathname,excludeRegExp));\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// Process directory specifier\\n\\t\\t\\t\\tvar dirPath = path.resolve(filepath,dirSpec.path);\\n\\t\\t\\t\\tif(fs.existsSync(dirPath) && fs.statSync(dirPath).isDirectory()) {\\n\\t\\t\\t\\t\\tvar\\tfiles = getAllFiles(dirPath, dirSpec.searchSubdirectories),\\n\\t\\t\\t\\t\\t\\tfileRegExp = new RegExp(dirSpec.filesRegExp || \\\"^.*$\\\"),\\n\\t\\t\\t\\t\\t\\tmetaRegExp = /^.*\\\\.meta$/;\\n\\t\\t\\t\\t\\tfor(var t=0; t<files.length; t++) {\\n\\t\\t\\t\\t\\t\\tvar thisPath = path.relative(filepath, files[t]),\\n\\t\\t\\t\\t\\t\\tfilename = path.basename(thisPath);\\n\\t\\t\\t\\t\\t\\tif(filename !== \\\"tiddlywiki.files\\\" && !metaRegExp.test(filename) && fileRegExp.test(filename)) {\\n\\t\\t\\t\\t\\t\\t\\tprocessFile(thisPath,dirSpec.isTiddlerFile,dirSpec.fields,dirSpec.isEditableFile,dirSpec.path);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tconsole.log(\\\"Warning: a directory in a tiddlywiki.files file does not exist.\\\");\\n\\t\\t\\t\\t\\tconsole.log(\\\"dirPath: \\\" + dirPath);\\n\\t\\t\\t\\t\\tconsole.log(\\\"tiddlywiki.files location: \\\" + filepath);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t});\\n\\t\\treturn tiddlers;\\n\\t};\\n\\t\\n\\t/*\\n\\tLoad the tiddlers from a plugin folder, and package them up into a proper JSON plugin tiddler\\n\\t*/\\n\\t$tw.loadPluginFolder = function(filepath,excludeRegExp) {\\n\\t\\texcludeRegExp = excludeRegExp || $tw.boot.excludeRegExp;\\n\\t\\tvar infoPath = filepath + path.sep + \\\"plugin.info\\\";\\n\\t\\tif(fs.existsSync(filepath) && fs.statSync(filepath).isDirectory()) {\\n\\t\\t\\t// Read the plugin information\\n\\t\\t\\tif(!fs.existsSync(infoPath) || !fs.statSync(infoPath).isFile()) {\\n\\t\\t\\t\\tconsole.log(\\\"Warning: missing plugin.info file in \\\" + filepath);\\n\\t\\t\\t\\treturn null;\\n\\t\\t\\t}\\n\\t\\t\\tvar pluginInfo = $tw.utils.parseJSONSafe(fs.readFileSync(infoPath,\\\"utf8\\\"),function() {return null;});\\n\\t\\t\\tif(!pluginInfo) {\\n\\t\\t\\t\\tconsole.log(\\\"warning: invalid JSON in plugin.info file at \\\" + infoPath);\\n\\t\\t\\t\\tpluginInfo = {};\\n\\t\\t\\t}\\n\\t\\t\\t// Read the plugin files\\n\\t\\t\\tvar pluginFiles = $tw.loadTiddlersFromPath(filepath,excludeRegExp);\\n\\t\\t\\t// Save the plugin tiddlers into the plugin info\\n\\t\\t\\tpluginInfo.tiddlers = pluginInfo.tiddlers || Object.create(null);\\n\\t\\t\\tfor(var f=0; f<pluginFiles.length; f++) {\\n\\t\\t\\t\\tvar tiddlers = pluginFiles[f].tiddlers;\\n\\t\\t\\t\\tfor(var t=0; t<tiddlers.length; t++) {\\n\\t\\t\\t\\t\\tvar tiddler= tiddlers[t];\\n\\t\\t\\t\\t\\tif(tiddler.title) {\\n\\t\\t\\t\\t\\t\\tpluginInfo.tiddlers[tiddler.title] = tiddler;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t// Give the plugin the same version number as the core if it doesn't have one\\n\\t\\t\\tif(!(\\\"version\\\" in pluginInfo)) {\\n\\t\\t\\t\\tpluginInfo.version = $tw.packageInfo.version;\\n\\t\\t\\t}\\n\\t\\t\\t// Use \\\"plugin\\\" as the plugin-type if we don't have one\\n\\t\\t\\tif(!(\\\"plugin-type\\\" in pluginInfo)) {\\n\\t\\t\\t\\tpluginInfo[\\\"plugin-type\\\"] = \\\"plugin\\\";\\n\\t\\t\\t}\\n\\t\\t\\tpluginInfo.dependents = pluginInfo.dependents || [];\\n\\t\\t\\tpluginInfo.type = \\\"application/json\\\";\\n\\t\\t\\t// Set plugin text\\n\\t\\t\\tpluginInfo.text = JSON.stringify({tiddlers: pluginInfo.tiddlers});\\n\\t\\t\\tdelete pluginInfo.tiddlers;\\n\\t\\t\\t// Deserialise array fields (currently required for the dependents field)\\n\\t\\t\\tfor(var field in pluginInfo) {\\n\\t\\t\\t\\tif($tw.utils.isArray(pluginInfo[field])) {\\n\\t\\t\\t\\t\\tpluginInfo[field] = $tw.utils.stringifyList(pluginInfo[field]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn pluginInfo;\\n\\t\\t} else {\\n\\t\\t\\t\\treturn null;\\n\\t\\t}\\n\\t};\\n\\t\\n\\t/*\\n\\tname: Name of the plugin to find\\n\\tpaths: array of file paths to search for it\\n\\tReturns the path of the plugin folder\\n\\t*/\\n\\t$tw.findLibraryItem = function(name,paths) {\\n\\t\\tvar pathIndex = 0;\\n\\t\\tdo {\\n\\t\\t\\tvar pluginPath = path.resolve(paths[pathIndex],\\\"./\\\" + name)\\n\\t\\t\\tif(fs.existsSync(pluginPath) && fs.statSync(pluginPath).isDirectory()) {\\n\\t\\t\\t\\treturn pluginPath;\\n\\t\\t\\t}\\n\\t\\t} while(++pathIndex < paths.length);\\n\\t\\treturn null;\\n\\t};\\n\\t\\n\\t/*\\n\\tname: Name of the plugin to load\\n\\tpaths: array of file paths to search for it\\n\\t*/\\n\\t$tw.loadPlugin = function(name,paths) {\\n\\t\\tvar pluginPath = $tw.findLibraryItem(name,paths);\\n\\t\\tif(pluginPath) {\\n\\t\\t\\tvar pluginFields = $tw.loadPluginFolder(pluginPath);\\n\\t\\t\\tif(pluginFields) {\\n\\t\\t\\t\\t$tw.wiki.addTiddler(pluginFields);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tconsole.log(\\\"Warning: Cannot find plugin '\\\" + name + \\\"'\\\");\\n\\t};\\n\\t\\n\\t/*\\n\\tlibraryPath: Path of library folder for these plugins (relative to core path)\\n\\tenvVar: Environment variable name for these plugins\\n\\tReturns an array of search paths\\n\\t*/\\n\\t$tw.getLibraryItemSearchPaths = function(libraryPath,envVar) {\\n\\t\\tvar pluginPaths = [path.resolve($tw.boot.corePath,libraryPath)],\\n\\t\\t\\tenv;\\n\\t\\tif(envVar) {\\n\\t\\t\\tenv = process.env[envVar];\\n\\t\\t\\tif(env) {\\n\\t\\t\\t\\tenv.split(path.delimiter).map(function(item) {\\n\\t\\t\\t\\t\\tif(item) {\\n\\t\\t\\t\\t\\t\\tpluginPaths.push(item);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn pluginPaths;\\n\\t};\\n\\t\\n\\t/*\\n\\tplugins: Array of names of plugins (eg, \\\"tiddlywiki/filesystemadaptor\\\")\\n\\tlibraryPath: Path of library folder for these plugins (relative to core path)\\n\\tenvVar: Environment variable name for these plugins\\n\\t*/\\n\\t$tw.loadPlugins = function(plugins,libraryPath,envVar) {\\n\\t\\tif(plugins) {\\n\\t\\t\\tvar pluginPaths = $tw.getLibraryItemSearchPaths(libraryPath,envVar);\\n\\t\\t\\tfor(var t=0; t<plugins.length; t++) {\\n\\t\\t\\t\\t$tw.loadPlugin(plugins[t],pluginPaths);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\t\\n\\t/*\\n\\tpath: path of wiki directory\\n\\toptions:\\n\\t\\tparentPaths: array of parent paths that we mustn't recurse into\\n\\t\\treadOnly: true if the tiddler file paths should not be retained\\n\\t*/\\n\\t$tw.loadWikiTiddlers = function(wikiPath,options) {\\n\\t\\toptions = options || {};\\n\\t\\tvar parentPaths = options.parentPaths || [],\\n\\t\\t\\twikiInfoPath = path.resolve(wikiPath,$tw.config.wikiInfo),\\n\\t\\t\\twikiInfo,\\n\\t\\t\\tpluginFields;\\n\\t\\t// Bail if we don't have a wiki info file\\n\\t\\tif(fs.existsSync(wikiInfoPath)) {\\n\\t\\t\\twikiInfo = $tw.utils.parseJSONSafe(fs.readFileSync(wikiInfoPath,\\\"utf8\\\"),function() {return null;});\\n\\t\\t\\tif(!wikiInfo) {\\n\\t\\t\\t\\tconsole.log(\\\"warning: invalid JSON in tiddlywiki.info file at \\\" + wikiInfoPath);\\n\\t\\t\\t\\twikiInfo = {};\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\treturn null;\\n\\t\\t}\\n\\t\\t// Save the path to the tiddlers folder for the filesystemadaptor\\n\\t\\tvar config = wikiInfo.config || {};\\n\\t\\tif($tw.boot.wikiPath == wikiPath) {\\n\\t\\t\\t$tw.boot.wikiTiddlersPath = path.resolve($tw.boot.wikiPath,config[\\\"default-tiddler-location\\\"] || $tw.config.wikiTiddlersSubDir);\\n\\t\\t}\\n\\t\\t// Load any parent wikis\\n\\t\\tif(wikiInfo.includeWikis) {\\n\\t\\t\\tparentPaths = parentPaths.slice(0);\\n\\t\\t\\tparentPaths.push(wikiPath);\\n\\t\\t\\t$tw.utils.each(wikiInfo.includeWikis,function(info) {\\n\\t\\t\\t\\tif(typeof info === \\\"string\\\") {\\n\\t\\t\\t\\t\\tinfo = {path: info};\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvar resolvedIncludedWikiPath = path.resolve(wikiPath,info.path);\\n\\t\\t\\t\\tif(parentPaths.indexOf(resolvedIncludedWikiPath) === -1) {\\n\\t\\t\\t\\t\\tvar subWikiInfo = $tw.loadWikiTiddlers(resolvedIncludedWikiPath,{\\n\\t\\t\\t\\t\\t\\tparentPaths: parentPaths,\\n\\t\\t\\t\\t\\t\\treadOnly: info[\\\"read-only\\\"]\\n\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t\\t// Merge the build targets\\n\\t\\t\\t\\t\\twikiInfo.build = $tw.utils.extend([],subWikiInfo.build,wikiInfo.build);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t$tw.utils.error(\\\"Cannot recursively include wiki \\\" + resolvedIncludedWikiPath);\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\t\\t}\\n\\t\\t// Load any plugins, themes and languages listed in the wiki info file\\n\\t\\t$tw.loadPlugins(wikiInfo.plugins,$tw.config.pluginsPath,$tw.config.pluginsEnvVar);\\n\\t\\t$tw.loadPlugins(wikiInfo.themes,$tw.config.themesPath,$tw.config.themesEnvVar);\\n\\t\\t$tw.loadPlugins(wikiInfo.languages,$tw.config.languagesPath,$tw.config.languagesEnvVar);\\n\\t\\t// Load the wiki files, registering them as writable\\n\\t\\tvar resolvedWikiPath = path.resolve(wikiPath,$tw.config.wikiTiddlersSubDir);\\n\\t\\t$tw.utils.each($tw.loadTiddlersFromPath(resolvedWikiPath),function(tiddlerFile) {\\n\\t\\t\\tif(!options.readOnly && tiddlerFile.filepath) {\\n\\t\\t\\t\\t$tw.utils.each(tiddlerFile.tiddlers,function(tiddler) {\\n\\t\\t\\t\\t\\t$tw.boot.files[tiddler.title] = {\\n\\t\\t\\t\\t\\t\\tfilepath: tiddlerFile.filepath,\\n\\t\\t\\t\\t\\t\\ttype: tiddlerFile.type,\\n\\t\\t\\t\\t\\t\\thasMetaFile: tiddlerFile.hasMetaFile,\\n\\t\\t\\t\\t\\t\\tisEditableFile: config[\\\"retain-original-tiddler-path\\\"] || tiddlerFile.isEditableFile || tiddlerFile.filepath.indexOf($tw.boot.wikiTiddlersPath) !== 0\\n\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t});\\n\\t\\t\\t}\\n\\t\\t\\t$tw.wiki.addTiddlers(tiddlerFile.tiddlers);\\n\\t\\t});\\n\\t\\tif($tw.boot.wikiPath == wikiPath) {\\n\\t\\t\\t// Save the original tiddler file locations if requested\\n\\t\\t\\tvar output = {}, relativePath, fileInfo;\\n\\t\\t\\tfor(var title in $tw.boot.files) {\\n\\t\\t\\t\\tfileInfo = $tw.boot.files[title];\\n\\t\\t\\t\\tif(fileInfo.isEditableFile) {\\n\\t\\t\\t\\t\\trelativePath = path.relative($tw.boot.wikiTiddlersPath,fileInfo.filepath);\\n\\t\\t\\t\\t\\tfileInfo.originalpath = relativePath;\\n\\t\\t\\t\\t\\toutput[title] =\\n\\t\\t\\t\\t\\t\\tpath.sep === \\\"/\\\" ?\\n\\t\\t\\t\\t\\t\\trelativePath :\\n\\t\\t\\t\\t\\t\\trelativePath.split(path.sep).join(\\\"/\\\");\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(Object.keys(output).length > 0){\\n\\t\\t\\t\\t$tw.wiki.addTiddler({title: \\\"$:/config/OriginalTiddlerPaths\\\", type: \\\"application/json\\\", text: JSON.stringify(output)});\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// Load any plugins within the wiki folder\\n\\t\\tvar wikiPluginsPath = path.resolve(wikiPath,$tw.config.wikiPluginsSubDir);\\n\\t\\tif(fs.existsSync(wikiPluginsPath)) {\\n\\t\\t\\tvar pluginFolders = fs.readdirSync(wikiPluginsPath);\\n\\t\\t\\tfor(var t=0; t<pluginFolders.length; t++) {\\n\\t\\t\\t\\tpluginFields = $tw.loadPluginFolder(path.resolve(wikiPluginsPath,\\\"./\\\" + pluginFolders[t]));\\n\\t\\t\\t\\tif(pluginFields) {\\n\\t\\t\\t\\t\\t$tw.wiki.addTiddler(pluginFields);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// Load any themes within the wiki folder\\n\\t\\tvar wikiThemesPath = path.resolve(wikiPath,$tw.config.wikiThemesSubDir);\\n\\t\\tif(fs.existsSync(wikiThemesPath)) {\\n\\t\\t\\tvar themeFolders = fs.readdirSync(wikiThemesPath);\\n\\t\\t\\tfor(var t=0; t<themeFolders.length; t++) {\\n\\t\\t\\t\\tpluginFields = $tw.loadPluginFolder(path.resolve(wikiThemesPath,\\\"./\\\" + themeFolders[t]));\\n\\t\\t\\t\\tif(pluginFields) {\\n\\t\\t\\t\\t\\t$tw.wiki.addTiddler(pluginFields);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// Load any languages within the wiki folder\\n\\t\\tvar wikiLanguagesPath = path.resolve(wikiPath,$tw.config.wikiLanguagesSubDir);\\n\\t\\tif(fs.existsSync(wikiLanguagesPath)) {\\n\\t\\t\\tvar languageFolders = fs.readdirSync(wikiLanguagesPath);\\n\\t\\t\\tfor(var t=0; t<languageFolders.length; t++) {\\n\\t\\t\\t\\tpluginFields = $tw.loadPluginFolder(path.resolve(wikiLanguagesPath,\\\"./\\\" + languageFolders[t]));\\n\\t\\t\\t\\tif(pluginFields) {\\n\\t\\t\\t\\t\\t$tw.wiki.addTiddler(pluginFields);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn wikiInfo;\\n\\t};\\n\\t\\n\\t$tw.loadTiddlersNode = function() {\\n\\t\\t// Load the boot tiddlers\\n\\t\\t$tw.utils.each($tw.loadTiddlersFromPath($tw.boot.bootPath),function(tiddlerFile) {\\n\\t\\t\\t$tw.wiki.addTiddlers(tiddlerFile.tiddlers);\\n\\t\\t});\\n\\t\\t// Load the core tiddlers\\n\\t\\t$tw.wiki.addTiddler($tw.loadPluginFolder($tw.boot.corePath));\\n\\t\\t// Load any extra plugins\\n\\t\\t$tw.utils.each($tw.boot.extraPlugins,function(name) {\\n\\t\\t\\tif(name.charAt(0) === \\\"+\\\") { // Relative path to plugin\\n\\t\\t\\t\\tvar pluginFields = $tw.loadPluginFolder(name.substring(1));\\n\\t\\t\\t\\tif(pluginFields) {\\n\\t\\t\\t\\t\\t$tw.wiki.addTiddler(pluginFields);\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tvar parts = name.split(\\\"/\\\"),\\n\\t\\t\\t\\t\\ttype = parts[0];\\n\\t\\t\\t\\tif(parts.length  === 3 && [\\\"plugins\\\",\\\"themes\\\",\\\"languages\\\"].indexOf(type) !== -1) {\\n\\t\\t\\t\\t\\t$tw.loadPlugins([parts[1] + \\\"/\\\" + parts[2]],$tw.config[type + \\\"Path\\\"],$tw.config[type + \\\"EnvVar\\\"]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t});\\n\\t\\t// Load the tiddlers from the wiki directory\\n\\t\\tif($tw.boot.wikiPath) {\\n\\t\\t\\t$tw.boot.wikiInfo = $tw.loadWikiTiddlers($tw.boot.wikiPath);\\n\\t\\t}\\n\\t};\\n\\t\\n\\t// End of if($tw.node)\\n\\t}\\n\\t\\n\\t/////////////////////////// Main startup function called once tiddlers have been decrypted\\n\\t\\n\\t/*\\n\\tStartup TiddlyWiki\\n\\t*/\\n\\t$tw.boot.initStartup = function(options) {\\n\\t\\t// Get the URL hash and check for safe mode\\n\\t\\t$tw.locationHash = \\\"#\\\";\\n\\t\\tif($tw.browser && !$tw.node) {\\n\\t\\t\\tif(location.hash === \\\"#:safe\\\") {\\n\\t\\t\\t\\t$tw.safeMode = true;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t$tw.locationHash = $tw.utils.getLocationHash();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// Initialise some more $tw properties\\n\\t\\t$tw.utils.deepDefaults($tw,{\\n\\t\\t\\tmodules: { // Information about each module\\n\\t\\t\\t\\ttitles: Object.create(null), // hashmap by module title of {fn:, exports:, moduleType:}\\n\\t\\t\\t\\ttypes: {} // hashmap by module type of hashmap of exports\\n\\t\\t\\t},\\n\\t\\t\\tconfig: { // Configuration overridables\\n\\t\\t\\t\\tpluginsPath: \\\"../plugins/\\\",\\n\\t\\t\\t\\tthemesPath: \\\"../themes/\\\",\\n\\t\\t\\t\\tlanguagesPath: \\\"../languages/\\\",\\n\\t\\t\\t\\teditionsPath: \\\"../editions/\\\",\\n\\t\\t\\t\\twikiInfo: \\\"./tiddlywiki.info\\\",\\n\\t\\t\\t\\twikiPluginsSubDir: \\\"./plugins\\\",\\n\\t\\t\\t\\twikiThemesSubDir: \\\"./themes\\\",\\n\\t\\t\\t\\twikiLanguagesSubDir: \\\"./languages\\\",\\n\\t\\t\\t\\twikiTiddlersSubDir: \\\"./tiddlers\\\",\\n\\t\\t\\t\\twikiOutputSubDir: \\\"./output\\\",\\n\\t\\t\\t\\tjsModuleHeaderRegExpString: \\\"^\\\\\\\\/\\\\\\\\*\\\\\\\\\\\\\\\\(?:\\\\\\\\r?\\\\\\\\n)((?:^[^\\\\\\\\r\\\\\\\\n]*(?:\\\\\\\\r?\\\\\\\\n))+?)(^\\\\\\\\\\\\\\\\\\\\\\\\*\\\\\\\\/$(?:\\\\\\\\r?\\\\\\\\n)?)\\\",\\n\\t\\t\\t\\tfileExtensionInfo: Object.create(null), // Map file extension to {type:}\\n\\t\\t\\t\\tcontentTypeInfo: Object.create(null), // Map type to {encoding:,extension:}\\n\\t\\t\\t\\tpluginsEnvVar: \\\"TIDDLYWIKI_PLUGIN_PATH\\\",\\n\\t\\t\\t\\tthemesEnvVar: \\\"TIDDLYWIKI_THEME_PATH\\\",\\n\\t\\t\\t\\tlanguagesEnvVar: \\\"TIDDLYWIKI_LANGUAGE_PATH\\\",\\n\\t\\t\\t\\teditionsEnvVar: \\\"TIDDLYWIKI_EDITION_PATH\\\"\\n\\t\\t\\t},\\n\\t\\t\\tlog: {}, // Log flags\\n\\t\\t\\tunloadTasks: []\\n\\t\\t});\\n\\t\\tif(!$tw.boot.tasks.readBrowserTiddlers) {\\n\\t\\t\\t// For writable tiddler files, a hashmap of title to {filepath:,type:,hasMetaFile:}\\n\\t\\t\\t$tw.boot.files = Object.create(null);\\n\\t\\t\\t// System paths and filenames\\n\\t\\t\\t$tw.boot.bootPath = options.bootPath || path.dirname(module.filename);\\n\\t\\t\\t$tw.boot.corePath = path.resolve($tw.boot.bootPath,\\\"../core\\\");\\n\\t\\t\\t// If there's no arguments then default to `--help`\\n\\t\\t\\tif($tw.boot.argv.length === 0) {\\n\\t\\t\\t\\t$tw.boot.argv = [\\\"--help\\\"];\\n\\t\\t\\t}\\n\\t\\t\\t// Parse any extra plugin references\\n\\t\\t\\t$tw.boot.extraPlugins = $tw.boot.extraPlugins || [];\\n\\t\\t\\twhile($tw.boot.argv[0] && $tw.boot.argv[0].indexOf(\\\"+\\\") === 0) {\\n\\t\\t\\t\\t$tw.boot.extraPlugins.push($tw.boot.argv[0].substring(1));\\n\\t\\t\\t\\t$tw.boot.argv.splice(0,1);\\n\\t\\t\\t}\\n\\t\\t\\t// If the first command line argument doesn't start with `--` then we\\n\\t\\t\\t// interpret it as the path to the wiki folder, which will otherwise default\\n\\t\\t\\t// to the current folder\\n\\t\\t\\tif($tw.boot.argv[0] && $tw.boot.argv[0].indexOf(\\\"--\\\") !== 0) {\\n\\t\\t\\t\\t$tw.boot.wikiPath = $tw.boot.argv[0];\\n\\t\\t\\t\\t$tw.boot.argv = $tw.boot.argv.slice(1);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t$tw.boot.wikiPath = process.cwd();\\n\\t\\t\\t}\\n\\t\\t\\t// Read package info\\n\\t\\t\\t$tw.packageInfo = $tw.packageInfo || require(\\\"../package.json\\\");\\n\\t\\t\\t// Check node version number\\n\\t\\t\\tif(!$tw.utils.checkVersions(process.version.substr(1),$tw.packageInfo.engines.node.substr(2))) {\\n\\t\\t\\t\\t$tw.utils.error(\\\"TiddlyWiki5 requires node.js version \\\" + $tw.packageInfo.engines.node);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// Add file extension information\\n\\t\\t$tw.utils.registerFileType(\\\"text/vnd.tiddlywiki\\\",\\\"utf8\\\",\\\".tid\\\");\\n\\t\\t$tw.utils.registerFileType(\\\"application/x-tiddler\\\",\\\"utf8\\\",\\\".tid\\\");\\n\\t\\t$tw.utils.registerFileType(\\\"application/x-tiddlers\\\",\\\"utf8\\\",\\\".multids\\\");\\n\\t\\t$tw.utils.registerFileType(\\\"application/x-tiddler-html-div\\\",\\\"utf8\\\",\\\".tiddler\\\");\\n\\t\\t$tw.utils.registerFileType(\\\"text/vnd.tiddlywiki2-recipe\\\",\\\"utf8\\\",\\\".recipe\\\");\\n\\t\\t$tw.utils.registerFileType(\\\"text/plain\\\",\\\"utf8\\\",\\\".txt\\\");\\n\\t\\t$tw.utils.registerFileType(\\\"text/css\\\",\\\"utf8\\\",\\\".css\\\");\\n\\t\\t$tw.utils.registerFileType(\\\"text/html\\\",\\\"utf8\\\",[\\\".html\\\",\\\".htm\\\"]);\\n\\t\\t$tw.utils.registerFileType(\\\"application/hta\\\",\\\"utf16le\\\",\\\".hta\\\",{deserializerType:\\\"text/html\\\"});\\n\\t\\t$tw.utils.registerFileType(\\\"application/javascript\\\",\\\"utf8\\\",\\\".js\\\");\\n\\t\\t$tw.utils.registerFileType(\\\"application/json\\\",\\\"utf8\\\",\\\".json\\\");\\n\\t\\t$tw.utils.registerFileType(\\\"application/pdf\\\",\\\"base64\\\",\\\".pdf\\\",{flags:[\\\"image\\\"]});\\n\\t\\t$tw.utils.registerFileType(\\\"application/zip\\\",\\\"base64\\\",\\\".zip\\\");\\n\\t\\t$tw.utils.registerFileType(\\\"application/x-zip-compressed\\\",\\\"base64\\\",\\\".zip\\\");\\n\\t\\t$tw.utils.registerFileType(\\\"image/jpeg\\\",\\\"base64\\\",[\\\".jpg\\\",\\\".jpeg\\\"],{flags:[\\\"image\\\"]});\\n\\t\\t$tw.utils.registerFileType(\\\"image/jpg\\\",\\\"base64\\\",[\\\".jpg\\\",\\\".jpeg\\\"],{flags:[\\\"image\\\"]});\\n\\t\\t$tw.utils.registerFileType(\\\"image/png\\\",\\\"base64\\\",\\\".png\\\",{flags:[\\\"image\\\"]});\\n\\t\\t$tw.utils.registerFileType(\\\"image/gif\\\",\\\"base64\\\",\\\".gif\\\",{flags:[\\\"image\\\"]});\\n\\t\\t$tw.utils.registerFileType(\\\"image/webp\\\",\\\"base64\\\",\\\".webp\\\",{flags:[\\\"image\\\"]});\\n\\t\\t$tw.utils.registerFileType(\\\"image/heic\\\",\\\"base64\\\",\\\".heic\\\",{flags:[\\\"image\\\"]});\\n\\t\\t$tw.utils.registerFileType(\\\"image/heif\\\",\\\"base64\\\",\\\".heif\\\",{flags:[\\\"image\\\"]});\\n\\t\\t$tw.utils.registerFileType(\\\"image/svg+xml\\\",\\\"utf8\\\",\\\".svg\\\",{flags:[\\\"image\\\"]});\\n\\t\\t$tw.utils.registerFileType(\\\"image/vnd.microsoft.icon\\\",\\\"base64\\\",\\\".ico\\\",{flags:[\\\"image\\\"]});\\n\\t\\t$tw.utils.registerFileType(\\\"image/x-icon\\\",\\\"base64\\\",\\\".ico\\\",{flags:[\\\"image\\\"]});\\n\\t\\t$tw.utils.registerFileType(\\\"application/wasm\\\",\\\"base64\\\",\\\".wasm\\\");\\n\\t\\t$tw.utils.registerFileType(\\\"application/font-woff\\\",\\\"base64\\\",\\\".woff\\\");\\n\\t\\t$tw.utils.registerFileType(\\\"application/x-font-ttf\\\",\\\"base64\\\",\\\".woff\\\");\\n\\t\\t$tw.utils.registerFileType(\\\"application/font-woff2\\\",\\\"base64\\\",\\\".woff2\\\");\\n\\t\\t$tw.utils.registerFileType(\\\"audio/ogg\\\",\\\"base64\\\",\\\".ogg\\\");\\n\\t\\t$tw.utils.registerFileType(\\\"audio/mp4\\\",\\\"base64\\\",[\\\".mp4\\\",\\\".m4a\\\"]);\\n\\t\\t$tw.utils.registerFileType(\\\"video/ogg\\\",\\\"base64\\\",[\\\".ogm\\\",\\\".ogv\\\",\\\".ogg\\\"]);\\n\\t\\t$tw.utils.registerFileType(\\\"video/webm\\\",\\\"base64\\\",\\\".webm\\\");\\n\\t\\t$tw.utils.registerFileType(\\\"video/mp4\\\",\\\"base64\\\",\\\".mp4\\\");\\n\\t\\t$tw.utils.registerFileType(\\\"audio/mp3\\\",\\\"base64\\\",\\\".mp3\\\");\\n\\t\\t$tw.utils.registerFileType(\\\"audio/mpeg\\\",\\\"base64\\\",[\\\".mp3\\\",\\\".m2a\\\",\\\".mp2\\\",\\\".mpa\\\",\\\".mpg\\\",\\\".mpga\\\"]);\\n\\t\\t$tw.utils.registerFileType(\\\"text/markdown\\\",\\\"utf8\\\",[\\\".md\\\",\\\".markdown\\\"],{deserializerType:\\\"text/x-markdown\\\"});\\n\\t\\t$tw.utils.registerFileType(\\\"text/x-markdown\\\",\\\"utf8\\\",[\\\".md\\\",\\\".markdown\\\"]);\\n\\t\\t$tw.utils.registerFileType(\\\"application/enex+xml\\\",\\\"utf8\\\",\\\".enex\\\");\\n\\t\\t$tw.utils.registerFileType(\\\"application/vnd.openxmlformats-officedocument.wordprocessingml.document\\\",\\\"base64\\\",\\\".docx\\\");\\n\\t\\t$tw.utils.registerFileType(\\\"application/msword\\\",\\\"base64\\\",\\\".doc\\\");\\n\\t\\t$tw.utils.registerFileType(\\\"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\\\",\\\"base64\\\",\\\".xlsx\\\");\\n\\t\\t$tw.utils.registerFileType(\\\"application/excel\\\",\\\"base64\\\",\\\".xls\\\");\\n\\t\\t$tw.utils.registerFileType(\\\"application/vnd.ms-excel\\\",\\\"base64\\\",\\\".xls\\\");\\n\\t\\t$tw.utils.registerFileType(\\\"application/vnd.openxmlformats-officedocument.presentationml.presentation\\\",\\\"base64\\\",\\\".pptx\\\");\\n\\t\\t$tw.utils.registerFileType(\\\"application/mspowerpoint\\\",\\\"base64\\\",\\\".ppt\\\");\\n\\t\\t$tw.utils.registerFileType(\\\"text/x-bibtex\\\",\\\"utf8\\\",\\\".bib\\\",{deserializerType:\\\"application/x-bibtex\\\"});\\n\\t\\t$tw.utils.registerFileType(\\\"application/x-bibtex\\\",\\\"utf8\\\",\\\".bib\\\");\\n\\t\\t$tw.utils.registerFileType(\\\"application/epub+zip\\\",\\\"base64\\\",\\\".epub\\\");\\n\\t\\t$tw.utils.registerFileType(\\\"application/octet-stream\\\",\\\"base64\\\",\\\".octet-stream\\\");\\n\\t\\t// Create the wiki store for the app\\n\\t\\t$tw.wiki = new $tw.Wiki($tw.safeMode && {enableIndexers: []});\\n\\t\\t// Install built in tiddler fields modules\\n\\t\\t$tw.Tiddler.fieldModules = $tw.modules.getModulesByTypeAsHashmap(\\\"tiddlerfield\\\");\\n\\t\\t// Install the tiddler deserializer modules\\n\\t\\t$tw.Wiki.tiddlerDeserializerModules = Object.create(null);\\n\\t\\t$tw.modules.applyMethods(\\\"tiddlerdeserializer\\\",$tw.Wiki.tiddlerDeserializerModules);\\n\\t\\t// Call unload handlers in the browser\\n\\t\\tif($tw.browser) {\\n\\t\\t\\twindow.onbeforeunload = function(event) {\\n\\t\\t\\t\\tevent = event || {};\\n\\t\\t\\t\\tvar result;\\n\\t\\t\\t\\t$tw.utils.each($tw.unloadTasks,function(task) {\\n\\t\\t\\t\\t\\tvar r = task(event);\\n\\t\\t\\t\\t\\tif(r) {\\n\\t\\t\\t\\t\\t\\tresult = r;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t});\\n\\t\\t\\t\\treturn result;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\t$tw.boot.loadStartup = function(options){\\n\\t\\n\\t\\t// Load tiddlers\\n\\t\\tif($tw.boot.tasks.readBrowserTiddlers) {\\n\\t\\t\\t$tw.loadTiddlersBrowser();\\n\\t\\t} else {\\n\\t\\t\\t$tw.loadTiddlersNode();\\n\\t\\t}\\n\\t\\t// Load any preloaded tiddlers\\n\\t\\tif($tw.preloadTiddlers) {\\n\\t\\t\\t$tw.wiki.addTiddlers($tw.preloadTiddlers);\\n\\t\\t}\\n\\t\\t// Give hooks a chance to modify the store\\n\\t\\t$tw.hooks.invokeHook(\\\"th-boot-tiddlers-loaded\\\");\\n\\t}\\n\\t$tw.boot.execStartup = function(options){\\n\\t\\t// Unpack plugin tiddlers\\n\\t\\t$tw.wiki.readPluginInfo();\\n\\t\\t$tw.wiki.registerPluginTiddlers(\\\"plugin\\\",$tw.safeMode ? [\\\"$:/core\\\"] : undefined);\\n\\t\\t$tw.wiki.unpackPluginTiddlers();\\n\\t\\t// Process \\\"safe mode\\\"\\n\\t\\tif($tw.safeMode) {\\n\\t\\t\\t$tw.wiki.processSafeMode();\\n\\t\\t}\\n\\t\\t// Register typed modules from the tiddlers we've just loaded\\n\\t\\t$tw.wiki.defineTiddlerModules();\\n\\t\\t// And any modules within plugins\\n\\t\\t$tw.wiki.defineShadowModules();\\n\\t\\t// Make sure the crypto state tiddler is up to date\\n\\t\\tif($tw.crypto) {\\n\\t\\t\\t$tw.crypto.updateCryptoStateTiddler();\\n\\t\\t}\\n\\t\\t// Gather up any startup modules\\n\\t\\t$tw.boot.remainingStartupModules = []; // Array of startup modules\\n\\t\\t$tw.modules.forEachModuleOfType(\\\"startup\\\",function(title,module) {\\n\\t\\t\\tif(module.startup) {\\n\\t\\t\\t\\t$tw.boot.remainingStartupModules.push(module);\\n\\t\\t\\t}\\n\\t\\t});\\n\\t\\t// Keep track of the startup tasks that have been executed\\n\\t\\t$tw.boot.executedStartupModules = Object.create(null);\\n\\t\\t$tw.boot.disabledStartupModules = $tw.boot.disabledStartupModules || [];\\n\\t\\t// Repeatedly execute the next eligible task\\n\\t\\t$tw.boot.executeNextStartupTask(options.callback);\\n\\t}\\n\\t/*\\n\\tStartup TiddlyWiki\\n\\t*/\\n\\t$tw.boot.startup = function(options) {\\n\\t\\toptions = options || {};\\n\\t\\t// Get the URL hash and check for safe mode\\n\\t\\t$tw.boot.initStartup(options);\\n\\t\\t$tw.boot.loadStartup(options);\\n\\t\\t$tw.boot.execStartup(options);\\n\\t};\\n\\t\\n\\t/*\\n\\tAdd another unload task\\n\\t*/\\n\\t$tw.addUnloadTask = function(task) {\\n\\t\\tif($tw.unloadTasks.indexOf(task) === -1) {\\n\\t\\t\\t$tw.unloadTasks.push(task);\\n\\t\\t}\\n\\t}\\n\\t\\n\\t/*\\n\\tExecute the remaining eligible startup tasks\\n\\t*/\\n\\t$tw.boot.executeNextStartupTask = function(callback) {\\n\\t\\t// Find the next eligible task\\n\\t\\tvar taskIndex = 0, task,\\n\\t\\t\\tasyncTaskCallback = function() {\\n\\t\\t\\t\\tif(task.name) {\\n\\t\\t\\t\\t\\t$tw.boot.executedStartupModules[task.name] = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn $tw.boot.executeNextStartupTask(callback);\\n\\t\\t\\t};\\n\\t\\twhile(taskIndex < $tw.boot.remainingStartupModules.length) {\\n\\t\\t\\ttask = $tw.boot.remainingStartupModules[taskIndex];\\n\\t\\t\\tif($tw.boot.isStartupTaskEligible(task)) {\\n\\t\\t\\t\\t// Remove this task from the list\\n\\t\\t\\t\\t$tw.boot.remainingStartupModules.splice(taskIndex,1);\\n\\t\\t\\t\\t// Assemble log message\\n\\t\\t\\t\\tvar s = [\\\"Startup task:\\\",task.name];\\n\\t\\t\\t\\tif(task.platforms) {\\n\\t\\t\\t\\t\\ts.push(\\\"platforms:\\\",task.platforms.join(\\\",\\\"));\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(task.after) {\\n\\t\\t\\t\\t\\ts.push(\\\"after:\\\",task.after.join(\\\",\\\"));\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(task.before) {\\n\\t\\t\\t\\t\\ts.push(\\\"before:\\\",task.before.join(\\\",\\\"));\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t$tw.boot.log(s.join(\\\" \\\"));\\n\\t\\t\\t\\t// Execute task\\n\\t\\t\\t\\tif(!$tw.utils.hop(task,\\\"synchronous\\\") || task.synchronous) {\\n\\t\\t\\t\\t\\ttask.startup();\\n\\t\\t\\t\\t\\tif(task.name) {\\n\\t\\t\\t\\t\\t\\t$tw.boot.executedStartupModules[task.name] = true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn $tw.boot.executeNextStartupTask(callback);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\ttask.startup(asyncTaskCallback);\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\ttaskIndex++;\\n\\t\\t}\\n\\t\\tif(typeof callback === 'function') {\\n\\t\\t\\tcallback();\\n\\t\\t}\\n\\t\\treturn false;\\n\\t};\\n\\t\\n\\t/*\\n\\tReturns true if we are running on one of the platforms specified in taskModule's\\n\\t`platforms` array; or if `platforms` property is not defined.\\n\\t*/\\n\\t$tw.boot.doesTaskMatchPlatform = function(taskModule) {\\n\\t\\tvar platforms = taskModule.platforms;\\n\\t\\tif(platforms) {\\n\\t\\t\\tfor(var t=0; t<platforms.length; t++) {\\n\\t\\t\\t\\tswitch(platforms[t]) {\\n\\t\\t\\t\\t\\tcase \\\"browser\\\":\\n\\t\\t\\t\\t\\t\\tif($tw.browser) {\\n\\t\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tcase \\\"node\\\":\\n\\t\\t\\t\\t\\t\\tif($tw.node) {\\n\\t\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tdefault:\\n\\t\\t\\t\\t\\t\\t$tw.utils.error(\\\"Module \\\" + taskModule.name + \\\": '\\\" + platforms[t] + \\\"' in export.platforms invalid\\\");\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\treturn true;\\n\\t};\\n\\t\\n\\t$tw.boot.isStartupTaskEligible = function(taskModule) {\\n\\t\\tvar t;\\n\\t\\t// Check that the platform is correct\\n\\t\\tif(!$tw.boot.doesTaskMatchPlatform(taskModule)) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tvar name = taskModule.name,\\n\\t\\t\\tremaining = $tw.boot.remainingStartupModules;\\n\\t\\tif(name) {\\n\\t\\t\\t// Fail if this module is disabled\\n\\t\\t\\tif($tw.boot.disabledStartupModules.indexOf(name) !== -1) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\t// Check that no other outstanding tasks must be executed before this one\\n\\t\\t\\tfor(t=0; t<remaining.length; t++) {\\n\\t\\t\\t\\tvar task = remaining[t];\\n\\t\\t\\t\\tif(task.before && task.before.indexOf(name) !== -1) {\\n\\t\\t\\t\\t\\tif($tw.boot.doesTaskMatchPlatform(task) && (!task.name || $tw.boot.disabledStartupModules.indexOf(task.name) === -1)) {\\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t// Check that all of the tasks that we must be performed after has been done\\n\\t\\tvar after = taskModule.after;\\n\\t\\tif(after) {\\n\\t\\t\\tfor(t=0; t<after.length; t++) {\\n\\t\\t\\t\\tif(!$tw.boot.executedStartupModules[after[t]]) {\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t};\\n\\t\\n\\t/*\\n\\tGlobal Hooks mechanism which allows plugins to modify default functionality\\n\\t*/\\n\\t$tw.hooks = $tw.hooks || { names: {}};\\n\\t\\n\\t/*\\n\\tAdd hooks to the  hashmap\\n\\t*/\\n\\t$tw.hooks.addHook = function(hookName,definition) {\\n\\t\\tif($tw.utils.hop($tw.hooks.names,hookName)) {\\n\\t\\t\\t$tw.hooks.names[hookName].push(definition);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\t$tw.hooks.names[hookName] = [definition];\\n\\t\\t}\\n\\t};\\n\\t\\n\\t/*\\n\\tDelete hooks from the hashmap\\n\\t*/\\n\\t$tw.hooks.removeHook = function(hookName,definition) {\\n\\t\\tif($tw.utils.hop($tw.hooks.names,hookName)) {\\n\\t\\t\\tvar p = $tw.hooks.names[hookName].indexOf(definition);\\n\\t\\t\\tif(p !== -1) {\\n\\t\\t\\t\\t$tw.hooks.names[hookName].splice(p, 1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\t\\n\\t/*\\n\\tInvoke the hook by key\\n\\t*/\\n\\t$tw.hooks.invokeHook = function(hookName /*, value,... */) {\\n\\t\\tvar args = Array.prototype.slice.call(arguments,1);\\n\\t\\tif($tw.utils.hop($tw.hooks.names,hookName)) {\\n\\t\\t\\tfor(var i = 0; i < $tw.hooks.names[hookName].length; i++) {\\n\\t\\t\\t\\targs[0] = $tw.hooks.names[hookName][i].apply(null,args);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn args[0];\\n\\t};\\n\\t\\n\\t/////////////////////////// Main boot function to decrypt tiddlers and then startup\\n\\t\\n\\t$tw.boot.boot = function(callback) {\\n\\t\\t// Initialise crypto object\\n\\t\\t$tw.crypto = new $tw.utils.Crypto();\\n\\t\\t$tw.CSE = new $tw.utils.CSE();\\n\\t\\t// Initialise password prompter\\n\\t\\tif($tw.browser && !$tw.node) {\\n\\t\\t\\t$tw.passwordPrompt = new $tw.utils.PasswordPrompt();\\n\\t\\t}\\n\\t\\t// Preload any encrypted tiddlers\\n\\t\\t$tw.boot.decryptEncryptedTiddlers(function() {\\n\\t\\t\\t// Startup\\n\\t\\t\\t$tw.boot.startup({callback: callback});\\n\\t\\t});\\n\\t};\\n\\t\\n\\t/////////////////////////// Autoboot in the browser\\n\\t\\n\\tif($tw.browser && !$tw.boot.suppressBoot) {\\n\\t\\t$tw.boot.boot();\\n\\t}\\n\\t\\n\\treturn $tw;\\n\\t\\n\\t});\\n\\t\\n\\tif(typeof(exports) !== \\\"undefined\\\") {\\n\\t\\texports.TiddlyWiki = _boot;\\n\\t} else {\\n\\t\\t_boot(window.$tw);\\n\\t}\\n\\t//# sourceURL=$:/boot/boot.js\\n\\t\",\"type\":\"application/javascript\"},\"$:/core/templates/store.area.template.html\":{\"title\":\"$:/core/templates/store.area.template.html\",\"text\":\"\\\\whitespace trim\\n<!-- Unencrypted -->\\n<$list filter=\\\"[[$:/isEncrypted]get[text]else[no]match[no]]\\\">\\n    <$list filter=\\\"[[storeAreaFormat]is[variable]getvariable[]else[json]match[json]]\\\">\\n        <!-- New-style JSON store area, with an old-style store area for compatibility with v5.1.x tooling -->\\n        `<script class=\\\"tiddlywiki-tiddler-store\\\" type=\\\"application/json\\\">[`\\n            <$let newline={{{ [charcode[10]] }}} join=`,$(newline)$`>\\n                <$text text=<<newline>>/>\\n                <$list filter=<<saveTiddlerFilter>> join=<<join>> template=\\\"$:/core/templates/html-json-tiddler\\\"/>\\n                <$list filter=\\\"[subfilter<skinnySaveTiddlerFilter>]\\\"  template=\\\"$:/core/templates/html-json-skinny-tiddler\\\"/>\\n                <$text text=<<newline>>/>\\n            </$let>\\n        `]</script>`\\n        `<div id=\\\"storeArea\\\" style=\\\"display:none;\\\">`\\n        `</div>`\\n    </$list>\\n    <$list filter=\\\"[[storeAreaFormat]is[variable]getvariable[]else[json]match[div]]\\\">\\n        <!-- Old-style DIV/PRE-based store area -->\\n        <$reveal type=\\\"nomatch\\\" state=\\\"$:/isEncrypted\\\" text=\\\"yes\\\">\\n            `<div id=\\\"storeArea\\\" style=\\\"display:none;\\\">`\\n                <$list filter={{{ [<saveTiddlerFilter>] }}} template=\\\"$:/core/templates/html-div-tiddler\\\"/>\\n                <$list filter=\\\"[subfilter<skinnySaveTiddlerFilter>]\\\" template=\\\"$:/core/templates/html-div-skinny-tiddler\\\"/>\\n            `</div>`\\n        </$reveal>\\n    </$list>\\n</$list>\\n<!-- Encrypted -->\\n<$list filter=\\\"[[$:/isEncrypted]get[text]else[no]match[yes]]\\\">\\n    `<!--~~ Encrypted tiddlers ~~-->`\\n    `<pre id=\\\"encryptedStoreArea\\\" type=\\\"text/plain\\\" style=\\\"display:none;\\\">`\\n        <$encrypt filter=<<saveTiddlerFilter>>/>\\n    `</pre>`\\n</$list>\\n<!-- CSEncrypted -->\\n<$list filter=\\\"[[$:/isCSEncrypted]get[text]else[no]match[yes]]\\\">\\n    `<!--~~ Encrypted tiddlers ~~-->`\\n    `<pre id=\\\"CSEncryptedMetaArea\\\" type=\\\"application/json\\\" style=\\\"display:none;\\\">`\\n        <<csemeta>>\\n    `</pre>`\\n</$list>\"},\"$:/plugins/tiddlywiki/tiddlyweb/tiddlywebadaptor.js\":{\"title\":\"$:/plugins/tiddlywiki/tiddlyweb/tiddlywebadaptor.js\",\"text\":\"/*\\\\\\ntitle: $:/plugins/tiddlywiki/tiddlyweb/tiddlywebadaptor.js\\ntype: application/javascript\\nmodule-type: syncadaptor\\n\\nA sync adaptor module for synchronising with TiddlyWeb compatible servers\\n\\n\\\\*/\\n(function(){\\n\\n/*jslint node: true, browser: true */\\n/*global $tw: false */\\n\\\"use strict\\\";\\n\\nvar CONFIG_HOST_TIDDLER = \\\"$:/config/tiddlyweb/host\\\",\\n\\tDEFAULT_HOST_TIDDLER = \\\"$protocol$//$host$/\\\";\\n\\nfunction TiddlyWebAdaptor(options) {\\n\\tthis.wiki = options.wiki;\\n\\tthis.host = this.getHost();\\n\\tthis.recipe = undefined;\\n\\tthis.hasStatus = false;\\n\\tthis.logger = new $tw.utils.Logger(\\\"TiddlyWebAdaptor\\\");\\n\\tthis.isLoggedIn = false;\\n\\tthis.isReadOnly = false;\\n\\tthis.logoutIsAvailable = true;\\n}\\n\\nTiddlyWebAdaptor.prototype.name = \\\"tiddlyweb\\\";\\n\\nTiddlyWebAdaptor.prototype.supportsLazyLoading = true;\\n\\nTiddlyWebAdaptor.prototype.setLoggerSaveBuffer = function(loggerForSaving) {\\n\\tthis.logger.setSaveBuffer(loggerForSaving);\\n};\\n\\nTiddlyWebAdaptor.prototype.isReady = function() {\\n\\treturn this.hasStatus;\\n};\\n\\nTiddlyWebAdaptor.prototype.getHost = function() {\\n\\tvar text = this.wiki.getTiddlerText(CONFIG_HOST_TIDDLER,DEFAULT_HOST_TIDDLER),\\n\\t\\tsubstitutions = [\\n\\t\\t\\t{name: \\\"protocol\\\", value: document.location.protocol},\\n\\t\\t\\t{name: \\\"host\\\", value: document.location.host}\\n\\t\\t];\\n\\tfor(var t=0; t<substitutions.length; t++) {\\n\\t\\tvar s = substitutions[t];\\n\\t\\ttext = $tw.utils.replaceString(text,new RegExp(\\\"\\\\\\\\$\\\" + s.name + \\\"\\\\\\\\$\\\",\\\"mg\\\"),s.value);\\n\\t}\\n\\treturn text;\\n};\\n\\nTiddlyWebAdaptor.prototype.getTiddlerInfo = function(tiddler) {\\n\\treturn {\\n\\t\\tbag: tiddler.fields.bag\\n\\t};\\n};\\n\\nTiddlyWebAdaptor.prototype.getTiddlerRevision = function(title) {\\n\\tvar tiddler = this.wiki.getTiddler(title);\\n\\treturn tiddler.fields.revision;\\n};\\n\\n/*\\nGet the current status of the TiddlyWeb connection\\n*/\\nTiddlyWebAdaptor.prototype.getStatus = function(callback) {\\n\\t// Get status\\n\\tvar self = this;\\n\\tthis.logger.log(\\\"Getting status\\\");\\n\\t$tw.utils.httpRequest({\\n\\t\\turl: this.host + \\\"status\\\",\\n\\t\\tcallback: function(err,data) {\\n\\t\\t\\tself.hasStatus = true;\\n\\t\\t\\tif(err) {\\n\\t\\t\\t\\treturn callback(err);\\n\\t\\t\\t}\\n\\t\\t\\t//If Browser-Storage plugin is present, cache pre-loaded tiddlers and add back after sync from server completes \\n\\t\\t\\tif($tw.browserStorage && $tw.browserStorage.isEnabled()) {\\n\\t\\t\\t\\t$tw.browserStorage.cachePreloadTiddlers();\\n\\t\\t\\t}\\n\\t\\t\\t// Decode the status JSON\\n\\t\\t\\tvar json = null;\\n\\t\\t\\ttry {\\n\\t\\t\\t\\tjson = JSON.parse(data);\\n\\t\\t\\t} catch(e) {\\n\\t\\t\\t}\\n\\t\\t\\tif(json) {\\n\\t\\t\\t\\tself.logger.log(\\\"Status:\\\",data);\\n\\t\\t\\t\\t// Record the recipe\\n\\t\\t\\t\\tif(json.space) {\\n\\t\\t\\t\\t\\tself.recipe = json.space.recipe;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// Check if we're logged in\\n\\t\\t\\t\\tself.isLoggedIn = json.username !== \\\"GUEST\\\";\\n\\t\\t\\t\\tself.isReadOnly = !!json[\\\"read_only\\\"];\\n\\t\\t\\t\\tself.isAnonymous = !!json.anonymous;\\n\\t\\t\\t\\tself.logoutIsAvailable = \\\"logout_is_available\\\" in json ? !!json[\\\"logout_is_available\\\"] : true;\\n\\t\\t\\t}\\n\\t\\t\\t// Invoke the callback if present\\n\\t\\t\\tif(callback) {\\n\\t\\t\\t\\tcallback(null,self.isLoggedIn,json.username,self.isReadOnly,self.isAnonymous);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t});\\n};\\n\\n/*\\nAttempt to login and invoke the callback(err)\\n*/\\nTiddlyWebAdaptor.prototype.login = function(username,password,callback) {\\n\\tvar options = {\\n\\t\\turl: this.host + \\\"challenge/tiddlywebplugins.tiddlyspace.cookie_form\\\",\\n\\t\\ttype: \\\"POST\\\",\\n\\t\\tdata: {\\n\\t\\t\\tuser: username,\\n\\t\\t\\tpassword: password,\\n\\t\\t\\ttiddlyweb_redirect: \\\"/status\\\" // workaround to marginalize automatic subsequent GET\\n\\t\\t},\\n\\t\\tcallback: function(err) {\\n\\t\\t\\tcallback(err);\\n\\t\\t},\\n\\t\\theaders: {\\n\\t\\t\\t\\\"accept\\\": \\\"application/json\\\",\\n\\t\\t\\t\\\"X-Requested-With\\\": \\\"TiddlyWiki\\\"\\n\\t\\t}\\n\\t};\\n\\tthis.logger.log(\\\"Logging in:\\\",options);\\n\\t$tw.utils.httpRequest(options);\\n};\\n\\n/*\\n*/\\nTiddlyWebAdaptor.prototype.logout = function(callback) {\\n\\tif(this.logoutIsAvailable) {\\n\\t\\tvar options = {\\n\\t\\t\\turl: this.host + \\\"logout\\\",\\n\\t\\t\\ttype: \\\"POST\\\",\\n\\t\\t\\tdata: {\\n\\t\\t\\t\\tcsrf_token: this.getCsrfToken(),\\n\\t\\t\\t\\ttiddlyweb_redirect: \\\"/status\\\" // workaround to marginalize automatic subsequent GET\\n\\t\\t\\t},\\n\\t\\t\\tcallback: function(err,data,xhr) {\\n\\t\\t\\t\\tcallback(err);\\n\\t\\t\\t},\\n\\t\\t\\theaders: {\\n\\t\\t\\t\\t\\\"accept\\\": \\\"application/json\\\",\\n\\t\\t\\t\\t\\\"X-Requested-With\\\": \\\"TiddlyWiki\\\"\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\tthis.logger.log(\\\"Logging out:\\\",options);\\n\\t\\t$tw.utils.httpRequest(options);\\n\\t} else {\\n\\t\\talert(\\\"This server does not support logging out. If you are using basic authentication the only way to logout is close all browser windows\\\");\\n\\t\\tcallback(null);\\n\\t}\\n};\\n\\n/*\\nRetrieve the CSRF token from its cookie\\n*/\\nTiddlyWebAdaptor.prototype.getCsrfToken = function() {\\n\\tvar regex = /^(?:.*; )?csrf_token=([^(;|$)]*)(?:;|$)/,\\n\\t\\tmatch = regex.exec(document.cookie),\\n\\t\\tcsrf = null;\\n\\tif(match && (match.length === 2)) {\\n\\t\\tcsrf = match[1];\\n\\t}\\n\\treturn csrf;\\n};\\n\\n/*\\nGet an array of skinny tiddler fields from the server\\n*/\\nTiddlyWebAdaptor.prototype.getSkinnyTiddlers = function(callback) {\\n\\tvar self = this;\\n\\t$tw.utils.httpRequest({\\n\\t\\turl: this.host + \\\"recipes/\\\" + this.recipe + \\\"/tiddlers.json\\\",\\n\\t\\tdata: {\\n\\t\\t\\tfilter: \\\"[all[tiddlers]] -[[$:/isEncrypted]] -[prefix[$:/temp/]] -[prefix[$:/status/]] -[[$:/boot/boot.js]] -[[$:/boot/bootprefix.js]] -[[$:/library/sjcl.js]] -[[$:/core]]\\\",\\n\\t\\t\\texclude: \\\"text,encrypted\\\"\\n\\t\\t},\\n\\t\\tcallback: function(err,data) {\\n\\t\\t\\t// Check for errors\\n\\t\\t\\tif(err) {\\n\\t\\t\\t\\treturn callback(err);\\n\\t\\t\\t}\\n\\t\\t\\t// Process the tiddlers to make sure the revision is a string\\n\\t\\t\\tvar tiddlers = JSON.parse(data);\\n\\t\\t\\tfor(var t=0; t<tiddlers.length; t++) {\\n\\t\\t\\t\\ttiddlers[t] = self.convertTiddlerFromTiddlyWebFormat(tiddlers[t]);\\n\\t\\t\\t}\\n\\t\\t\\t// Invoke the callback with the skinny tiddlers\\n\\t\\t\\tcallback(null,tiddlers);\\n\\t\\t\\t// If Browswer Storage tiddlers were cached on reloading the wiki, add them after sync from server completes in the above callback.\\n\\t\\t\\tif($tw.browserStorage && $tw.browserStorage.isEnabled()) { \\n\\t\\t\\t\\t$tw.browserStorage.addCachedTiddlers();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t});\\n};\\n\\n/*\\nSave a tiddler and invoke the callback with (err,adaptorInfo,revision)\\n*/\\nTiddlyWebAdaptor.prototype.saveTiddler = function(tiddler,callback,options) {\\n\\tvar self = this;\\n\\tif(this.isReadOnly) {\\n\\t\\treturn callback(null);\\n\\t}\\n\\tvar CSEState = $tw.wiki.getTiddlerText(\\\"$:/isCSEncrypted\\\", \\\"no\\\")\\n\\tvar CSEFilter = $tw.wiki.getTiddlerText('$:/config/TW5-CSE/EncryptFilter',\\\"[all[]!is[system]]\\\")\\n\\tvar CSEFilterArr = $tw.wiki.filterTiddlers(`${CSEFilter} :filter[field:title[${tiddler.fields.title}]]`)\\n\\tif(CSEState === 'yes' && CSEFilterArr.length == 1 && CSEFilterArr[0] === tiddler.fields.title )\\n\\t\\ttiddler = new $tw.Tiddler(\\n\\t\\t\\t{\\n\\t\\t\\t\\ttitle: tiddler.fields.title,\\n\\t\\t\\t\\ttext: \\\"CSEncrypted\\\",\\n\\t\\t\\t\\tencrypted: $tw.CSE.encryptFields(tiddler.fields.title),\\n\\t\\t\\t}\\n\\t\\t)\\n\\t$tw.utils.httpRequest({\\n\\t\\turl: this.host + \\\"recipes/\\\" + encodeURIComponent(this.recipe) + \\\"/tiddlers/\\\" + encodeURIComponent(tiddler.fields.title),\\n\\t\\ttype: \\\"PUT\\\",\\n\\t\\theaders: {\\n\\t\\t\\t\\\"Content-type\\\": \\\"application/json\\\"\\n\\t\\t},\\n\\t\\tdata: this.convertTiddlerToTiddlyWebFormat(tiddler),\\n\\t\\tcallback: function(err,data,request) {\\n\\t\\t\\tif(err) {\\n\\t\\t\\t\\treturn callback(err);\\n\\t\\t\\t}\\n\\t\\t\\t//If Browser-Storage plugin is present, remove tiddler from local storage after successful sync to the server\\n\\t\\t\\tif($tw.browserStorage && $tw.browserStorage.isEnabled()) {\\n\\t\\t\\t\\t$tw.browserStorage.removeTiddlerFromLocalStorage(tiddler.fields.title)\\n\\t\\t\\t}\\n\\t\\t\\t// Save the details of the new revision of the tiddler\\n\\t\\t\\tvar etag = request.getResponseHeader(\\\"Etag\\\");\\n\\t\\t\\tif(!etag) {\\n\\t\\t\\t\\tcallback(\\\"Response from server is missing required `etag` header\\\");\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tvar etagInfo = self.parseEtag(etag);\\n\\t\\t\\t\\t// Invoke the callback\\n\\t\\t\\t\\tcallback(null,{\\n\\t\\t\\t\\t\\tbag: etagInfo.bag\\n\\t\\t\\t\\t},etagInfo.revision);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t});\\n};\\n\\n/*\\nLoad a tiddler and invoke the callback with (err,tiddlerFields)\\n*/\\nTiddlyWebAdaptor.prototype.loadTiddler = function(title,callback) {\\n\\tvar self = this;\\n\\t$tw.utils.httpRequest({\\n\\t\\turl: this.host + \\\"recipes/\\\" + encodeURIComponent(this.recipe) + \\\"/tiddlers/\\\" + encodeURIComponent(title),\\n\\t\\tcallback: function(err,data,request) {\\n\\t\\t\\tif(err) {\\n\\t\\t\\t\\treturn callback(err);\\n\\t\\t\\t}\\n\\t\\t\\t// Invoke the callback\\n\\t\\t\\tdata = self.convertTiddlerFromTiddlyWebFormat(JSON.parse(data))\\n\\t\\t\\tif($tw.utils.hop(data,\\\"encrypted\\\")) {\\n\\t\\t\\t\\tvar decryptedFields = $tw.CSE.decryptFields(data)\\n\\t\\t\\t\\tif(decryptedFields) {\\n\\t\\t\\t\\t\\tif($tw.utils.hop(data,\\\"revision\\\") && $tw.utils.hop(data,\\\"bag\\\") )\\n\\t\\t\\t\\t\\t\\tdecryptedFields = $tw.utils.extend(decryptedFields,{\\n\\t\\t\\t\\t\\t\\t\\trevision: data.revision,\\n\\t\\t\\t\\t\\t\\t\\tbag: data.bag\\n\\t\\t\\t\\t\\t\\t})\\n\\t\\t\\t\\t\\tdata = decryptedFields\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tcallback(null, data);\\n\\t\\t}\\n\\t});\\n};\\n\\n/*\\nDelete a tiddler and invoke the callback with (err)\\noptions include:\\ntiddlerInfo: the syncer's tiddlerInfo for this tiddler\\n*/\\nTiddlyWebAdaptor.prototype.deleteTiddler = function(title,callback,options) {\\n\\tvar self = this;\\n\\tif(this.isReadOnly) {\\n\\t\\treturn callback(null);\\n\\t}\\n\\t// If we don't have a bag it means that the tiddler hasn't been seen by the server, so we don't need to delete it\\n\\tvar bag = options.tiddlerInfo.adaptorInfo && options.tiddlerInfo.adaptorInfo.bag;\\n\\tif(!bag) {\\n\\t\\treturn callback(null,options.tiddlerInfo.adaptorInfo);\\n\\t}\\n\\t// Issue HTTP request to delete the tiddler\\n\\t$tw.utils.httpRequest({\\n\\t\\turl: this.host + \\\"bags/\\\" + encodeURIComponent(bag) + \\\"/tiddlers/\\\" + encodeURIComponent(title),\\n\\t\\ttype: \\\"DELETE\\\",\\n\\t\\tcallback: function(err,data,request) {\\n\\t\\t\\tif(err) {\\n\\t\\t\\t\\treturn callback(err);\\n\\t\\t\\t}\\n\\t\\t\\t// Invoke the callback & return null adaptorInfo\\n\\t\\t\\tcallback(null,null);\\n\\t\\t}\\n\\t});\\n};\\n\\n/*\\nConvert a tiddler to a field set suitable for PUTting to TiddlyWeb\\n*/\\nTiddlyWebAdaptor.prototype.convertTiddlerToTiddlyWebFormat = function(tiddler) {\\n\\tvar result = {},\\n\\t\\tknownFields = [\\n\\t\\t\\t\\\"bag\\\", \\\"created\\\", \\\"creator\\\", \\\"modified\\\", \\\"modifier\\\", \\\"permissions\\\", \\\"recipe\\\", \\\"revision\\\", \\\"tags\\\", \\\"text\\\", \\\"title\\\", \\\"type\\\", \\\"uri\\\"\\n\\t\\t];\\n\\tif(tiddler) {\\n\\t\\t$tw.utils.each(tiddler.fields,function(fieldValue,fieldName) {\\n\\t\\t\\tvar fieldString = fieldName === \\\"tags\\\" ?\\n\\t\\t\\t\\t\\t\\t\\t\\ttiddler.fields.tags :\\n\\t\\t\\t\\t\\t\\t\\t\\ttiddler.getFieldString(fieldName); // Tags must be passed as an array, not a string\\n\\n\\t\\t\\tif(knownFields.indexOf(fieldName) !== -1) {\\n\\t\\t\\t\\t// If it's a known field, just copy it across\\n\\t\\t\\t\\tresult[fieldName] = fieldString;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// If it's unknown, put it in the \\\"fields\\\" field\\n\\t\\t\\t\\tresult.fields = result.fields || {};\\n\\t\\t\\t\\tresult.fields[fieldName] = fieldString;\\n\\t\\t\\t}\\n\\t\\t});\\n\\t}\\n\\t// Default the content type\\n\\tresult.type = result.type || \\\"text/vnd.tiddlywiki\\\";\\n\\treturn JSON.stringify(result,null,$tw.config.preferences.jsonSpaces);\\n};\\n\\n/*\\nConvert a field set in TiddlyWeb format into ordinary TiddlyWiki5 format\\n*/\\nTiddlyWebAdaptor.prototype.convertTiddlerFromTiddlyWebFormat = function(tiddlerFields) {\\n\\tvar self = this,\\n\\t\\tresult = {};\\n\\t// Transfer the fields, pulling down the `fields` hashmap\\n\\t$tw.utils.each(tiddlerFields,function(element,title,object) {\\n\\t\\tif(title === \\\"fields\\\") {\\n\\t\\t\\t$tw.utils.each(element,function(element,subTitle,object) {\\n\\t\\t\\t\\tresult[subTitle] = element;\\n\\t\\t\\t});\\n\\t\\t} else {\\n\\t\\t\\tresult[title] = tiddlerFields[title];\\n\\t\\t}\\n\\t});\\n\\t// Make sure the revision is expressed as a string\\n\\tif(typeof result.revision === \\\"number\\\") {\\n\\t\\tresult.revision = result.revision.toString();\\n\\t}\\n\\t// Some unholy freaking of content types\\n\\tif(result.type === \\\"text/javascript\\\") {\\n\\t\\tresult.type = \\\"application/javascript\\\";\\n\\t} else if(!result.type || result.type === \\\"None\\\") {\\n\\t\\tresult.type = \\\"text/x-tiddlywiki\\\";\\n\\t}\\n\\treturn result;\\n};\\n\\n/*\\nSplit a TiddlyWeb Etag into its constituent parts. For example:\\n\\n```\\n\\\"system-images_public/unsyncedIcon/946151:9f11c278ccde3a3149f339f4a1db80dd4369fc04\\\"\\n```\\n\\nNote that the value includes the opening and closing double quotes.\\n\\nThe parts are:\\n\\n```\\n<bag>/<title>/<revision>:<hash>\\n```\\n*/\\nTiddlyWebAdaptor.prototype.parseEtag = function(etag) {\\n\\tvar firstSlash = etag.indexOf(\\\"/\\\"),\\n\\t\\tlastSlash = etag.lastIndexOf(\\\"/\\\"),\\n\\t\\tcolon = etag.lastIndexOf(\\\":\\\");\\n\\tif(firstSlash === -1 || lastSlash === -1 || colon === -1) {\\n\\t\\treturn null;\\n\\t} else {\\n\\t\\treturn {\\n\\t\\t\\tbag: $tw.utils.decodeURIComponentSafe(etag.substring(1,firstSlash)),\\n\\t\\t\\ttitle: $tw.utils.decodeURIComponentSafe(etag.substring(firstSlash + 1,lastSlash)),\\n\\t\\t\\trevision: etag.substring(lastSlash + 1,colon)\\n\\t\\t};\\n\\t}\\n};\\n\\nif($tw.browser && document.location.protocol.substr(0,4) === \\\"http\\\" ) {\\n\\texports.adaptorClass = TiddlyWebAdaptor;\\n}\\n\\n})();\\n\",\"type\":\"application/javascript\",\"module-type\":\"syncadaptor\"},\"$:/plugins/FSpark/TW5-CSE/password-message.js\":{\"title\":\"$:/plugins/FSpark/TW5-CSE/password-message.js\",\"text\":\"/*\\\\\\nmodified: 20230404153030450\\nmodule-type: startup\\ntitle: $:/plugins/FSpark/TW5-CSE/password-message.js\\ntype: application/javascript\\n\\n\\\\*/\\n\\n\\\"use strict\\\";\\n\\nfunction _typeof(obj) {\\n  \\\"@babel/helpers - typeof\\\";\\n\\n  return _typeof = \\\"function\\\" == typeof Symbol && \\\"symbol\\\" == typeof Symbol.iterator ? function (obj) {\\n    return typeof obj;\\n  } : function (obj) {\\n    return obj && \\\"function\\\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj;\\n  }, _typeof(obj);\\n}\\n(function () {\\n  /*jslint node: true, browser: true */\\n  /*global $tw: false */\\n  \\\"use strict\\\";\\n\\n  // Export name and synchronous status\\n  exports.name = \\\"cse-password\\\";\\n  exports.platforms = [\\\"browser\\\"];\\n  exports.after = [\\\"startup\\\"];\\n  exports.synchronous = true;\\n  exports.startup = function () {\\n    $tw.rootWidget.addEventListener(\\\"tm-cse-set-password\\\", function (event) {\\n      if (!checkCSE()) return;\\n      var params, password;\\n      if (_typeof(event.paramObject) === \\\"object\\\") {\\n        params = event.paramObject;\\n      }\\n      if (_typeof(event.param) === \\\"object\\\") {\\n        // Backwards compatibility with 5.1.3\\n        params = event.param;\\n      }\\n      if (params && params.password) {\\n        password = params.password;\\n      }\\n      if (password) {\\n        $tw.CSE.setPassword(password);\\n        $tw.CSE.forcePush();\\n      } else {\\n        $tw.passwordPrompt.createPrompt({\\n          serviceName: $tw.language.getString(\\\"Encryption/PromptSetPassword\\\"),\\n          noUserName: true,\\n          submitText: $tw.language.getString(\\\"Encryption/SetPassword\\\"),\\n          canCancel: true,\\n          repeatPassword: true,\\n          callback: function callback(data) {\\n            if (data) {\\n              void 0;\\n              $tw.CSE.setPassword(data.password);\\n              $tw.CSE.forcePush();\\n              return true; // Get rid of the password prompt\\n            }\\n          }\\n        });\\n      }\\n    });\\n\\n    $tw.rootWidget.addEventListener(\\\"tm-cse-clear-password\\\", function (event) {\\n      if (!checkCSE()) return;\\n      if ($tw.browser) {\\n        if (!confirm($tw.language.getString(\\\"Encryption/ConfirmClearPassword\\\"))) {\\n          return;\\n        }\\n      }\\n      $tw.CSE.setPassword(null);\\n      $tw.CSE.forcePush();\\n    });\\n    $tw.rootWidget.addEventListener(\\\"tm-cse-remember-password\\\", function (event) {\\n      if (!checkCSE()) return;\\n      if ($tw.browser) {\\n        $tw.CSE.rememberPassword();\\n      }\\n    });\\n    $tw.rootWidget.addEventListener(\\\"tm-cse-forget-password\\\", function (event) {\\n      if (!checkCSE()) return;\\n      if ($tw.browser) {\\n        $tw.CSE.forgetPassword();\\n      }\\n    });\\n    function checkCSE() {\\n      if ($tw.CSE) {\\n        $tw.wiki.addTiddler({\\n          title: \\\"$:/state/cse-booted\\\",\\n          text: \\\"yes\\\"\\n        });\\n        return true;\\n      } else {\\n        $tw.wiki.addTiddler({\\n          title: \\\"$:/state/cse-booted\\\",\\n          text: \\\"no\\\"\\n        });\\n        void 0;\\n        return false;\\n      }\\n    }\\n    $tw.rootWidget.addEventListener(\\\"tm-cse-check-boot\\\", function (event) {\\n      if ($tw.browser) {\\n        if ($tw.CSE) {\\n          checkCSE();\\n        }\\n      }\\n    });\\n    // Ensure that $:/isCSEncrypted is maintained properly\\n    $tw.wiki.addEventListener(\\\"change\\\", function (changes) {\\n      if ($tw.utils.hop(changes, \\\"$:/isCSEncrypted\\\")) {\\n        $tw.CSE.updateCryptoStateTiddler();\\n      }\\n    });\\n  };\\n})();\\n\",\"modified\":\"20230404153030450\",\"module-type\":\"startup\",\"type\":\"application/javascript\"},\"$:/plugins/FSpark/TW5-CSE/settings/check\":{\"title\":\"$:/plugins/FSpark/TW5-CSE/settings/check\",\"caption\":\"Check\",\"type\":\"text/vnd.tiddlywiki\",\"text\":\"!! Check boot\\n\\n<$macrocall $name=\\\"invoke\\\" action=\\\"\\\"\\\"<$action-sendmessage $message=\\\"tm-cse-check-boot\\\"/>\\\"\\\"\\\"/>\\n\\n<$reveal type=\\\"match\\\" state=\\\"$:/state/cse-booted\\\" text=\\\"yes\\\">\\n\\nCSE started successfully, let's start encryption！\\n\\n</$reveal>\\n<$reveal type=\\\"nomatch\\\" state=\\\"$:/state/cse-booted\\\" text=\\\"yes\\\">\\n\\n<$error $message=\\\"CSE failed to start successfully, please read the documentation carefully or ask for help.\\\"/>\\n\\n</$reveal>\\n\"},\"$:/plugins/FSpark/TW5-CSE/settings/filter\":{\"title\":\"$:/plugins/FSpark/TW5-CSE/settings/filter\",\"caption\":\"Filter\",\"type\":\"text/vnd.tiddlywiki\",\"text\":\"\\\\define dynamicvars(currentVars, content)\\n<$vars $currentVars$ >\\n$content$\\n</$vars>\\n\\\\end\\n\\n\\\\define applyActions()\\n<$action-setfield $tiddler=\\\"$:/config/TW5-CSE/EncryptFilter\\\" text={{$:/temp/CSE/new-filter}} />\\n<$action-cse-forcepush $filter={{$:/plugins/FSpark/TW5-CSE/filters/union}} />\\n\\\\end\\n\\n\\\\define applyButton()\\n<$button actions=<<applyActions>>>Apply New Filter and Push to Server</$button>\\n\\\\end\\n\\n!! Change Filter\\n\\n|tc-table-no-border|k\\n|Old Filter: |<$edit-text tiddler=\\\"$:/config/TW5-CSE/EncryptFilter\\\" tag=input disabled=\\\"yes\\\"/>|\\n|New Filter: |<$edit-text tiddler=\\\"$:/temp/CSE/new-filter\\\" tag=input/>|\\n\\n<$set name=\\\"oldfilter\\\" tiddler=\\\"$:/config/TW5-CSE/EncryptFilter\\\" >\\n<$set name=\\\"newfilter\\\" tiddler=\\\"$:/temp/CSE/new-filter\\\" >\\n\\n<$macrocall $name=\\\"dynamicvars\\\" currentVars={{{ [[$:/plugins/FSpark/TW5-CSE/filters/union]get[vars]] }}} content=<<applyButton>> />\\n\\n<<tabs \\\"[all[shadows]prefix[$:/plugins/FSpark/TW5-CSE/filters]]\\\" \\\"\\\" \\\"\\\" \\\"\\\" \\\"$:/plugins/FSpark/TW5-CSE/templates/filtersResults\\\" \\\"$:/plugins/FSpark/TW5-CSE/templates/filtersButton\\\">>\\n</$set>\\n</$set>\\n\\n\"},\"$:/plugins/FSpark/TW5-CSE/settings/password\":{\"title\":\"$:/plugins/FSpark/TW5-CSE/settings/password\",\"caption\":\"Password\",\"type\":\"text/vnd.tiddlywiki\",\"text\":\"\\\\define rmbpwd() <$action-sendmessage $message=\\\"tm-cse-remember-password\\\" />\\n\\\\define fgtpwd() <$action-sendmessage $message=\\\"tm-cse-forget-passwordl\\\" />\\n\\n!! Clear Password\\n\\n<$button >Clear Password\\n<$action-sendmessage $message=\\\"tm-cse-clear-password\\\" />\\n</$button>\\n\\n!! Change Password\\n\\n|tc-table-no-border|k\\n|New Password: |<$edit-text tiddler=\\\"$:/temp/cse/newpassword\\\" tag=input type=password/>|\\n|Confirm Password: |<$edit-text tiddler=\\\"$:/temp/cse/confirmpassword\\\" tag=input type=password/>|\\n\\n<$button disabled={{{ [{$:/temp/cse/newpassword}match[]then[yes]else[no]] [{$:/temp/cse/newpassword}match{$:/temp/cse/confirmpassword}then[no]else[yes]] +[match[yes]else[no]] }}}>\\nChange Password\\n<$action-sendmessage $message=\\\"tm-cse-set-password\\\" password={{$:/temp/cse/newpassword}}/>\\n</$button>\\n\\n!! Other\\n\\n<$checkbox tiddler=\\\"$:/plugins/FSpark/TW5-CSE/metaconfig.json\\\" index=\\\"RmbPwd\\\" checked=\\\"yes\\\" unchecked=\\\"no\\\" checkactions=<<rmbpwd>> uncheckactions=<<fgtpwd>> > Make this browser remember password</$checkbox>\"},\"$:/plugins/FSpark/TW5-CSE/templates/filtersButton\":{\"title\":\"$:/plugins/FSpark/TW5-CSE/templates/filtersButton\",\"type\":\"text/vnd.tiddlywiki\",\"text\":\"\\\\define tabCaption()\\n<$set name=\\\"currentFilter\\\" tiddler=<<currentTab>> >\\n{{{ [<currentTab>get[caption]] }}}: <$count filter=<<currentFilter>> />\\n</$set>\\n\\\\end\\n\\n<$macrocall $name=\\\"dynamicvars\\\" currentVars={{{ [<currentTab>get[vars]] }}} content=<<tabCaption>> />\"},\"$:/plugins/FSpark/TW5-CSE/templates/filtersResults\":{\"title\":\"$:/plugins/FSpark/TW5-CSE/templates/filtersResults\",\"type\":\"text/vnd.tiddlywiki\",\"text\":\"\\\\define listResults()\\n<$text text=<<hahaha>> />\\n\\n<$set name=\\\"currentFilter\\\" tiddler=<<currentTab>> >\\n\\n<$text text=<<currentFilter>>/>\\n\\n<$list filter=<<currentFilter>>/>\\n\\n</$set>\\n\\\\end\\n\\n<$macrocall $name=\\\"dynamicvars\\\" currentVars={{{ [<currentTab>get[vars]] }}} content=<<listResults>> />\\n\"},\"$:/plugins/FSpark/TW5-CSE/ui/cloud-locked\":{\"title\":\"$:/plugins/FSpark/TW5-CSE/ui/cloud-locked\",\"type\":\"text/vnd.tiddlywiki\",\"text\":\"<svg class=\\\"tc-image-button\\\" width=\\\"22pt\\\" height=\\\"22pt\\\" viewBox=\\\"0 0 1024 1024\\\" version=\\\"1.1\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" p-id=\\\"3608\\\"><path d=\\\"M785.92 286.72A298.666667 298.666667 0 0 0 215.893333 367.36a170.666667 170.666667 0 0 0-16.213333 326.826667c4.437333 1.365333 9.002667 2.090667 13.653333 2.133333a43.221333 43.221333 0 1 0 13.653334-85.333333A85.333333 85.333333 0 0 1 170.666667 533.333333a85.333333 85.333333 0 0 1 85.333333-85.333333 42.666667 42.666667 0 0 0 42.666667-42.666667 213.333333 213.333333 0 0 1 415.146666-68.693333 42.666667 42.666667 0 0 0 33.28 28.586667 128 128 0 0 1 42.666667 235.946666 42.794667 42.794667 0 0 0 42.666667 74.24A213.333333 213.333333 0 0 0 938.666667 490.666667a213.333333 213.333333 0 0 0-152.746667-203.946667z m-145.92 384V618.666667a128 128 0 1 0-256 0v50.346666a128 128 0 0 0 42.666667 248.32h170.666666a128 128 0 0 0 42.666667-248.32v1.706667z m-170.666667-52.053333a42.666667 42.666667 0 1 1 85.333334 0v42.666666h-85.333334v-42.666666z m128 213.333333h-170.666666a42.666667 42.666667 0 1 1 0-85.333333h170.666666a42.666667 42.666667 0 1 1 0 85.333333z\\\" p-id=\\\"3609\\\"></path></svg>\"},\"$:/plugins/FSpark/TW5-CSE/ui/cloud-unlocked\":{\"title\":\"$:/plugins/FSpark/TW5-CSE/ui/cloud-unlocked\",\"type\":\"text/vnd.tiddlywiki\",\"text\":\"<svg class=\\\"tc-image-button\\\" width=\\\"22pt\\\" height=\\\"22pt\\\" viewBox=\\\"0 0 1024 1024\\\" version=\\\"1.1\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" p-id=\\\"2717\\\" id=\\\"mx_n_1680424307777\\\"><path d=\\\"M597.333333 661.333333h-128v-42.666666a42.666667 42.666667 0 0 1 80.213334-21.333334 42.666667 42.666667 0 0 0 58.453333 14.506667 42.666667 42.666667 0 0 0 14.506667-57.173333 131.413333 131.413333 0 0 0-19.626667-25.173334A128 128 0 0 0 512 490.666667a128 128 0 0 0-128 128v50.346666a128 128 0 0 0 42.666667 248.32h170.666666a128 128 0 1 0 0-256z m0 170.666667h-170.666666a42.666667 42.666667 0 1 1 0-85.333333h170.666666a42.666667 42.666667 0 1 1 0 85.333333z m188.586667-545.28A298.666667 298.666667 0 0 0 215.893333 367.36a170.666667 170.666667 0 0 0-16.213333 326.826667c4.437333 1.365333 9.002667 2.090667 13.653333 2.133333a43.221333 43.221333 0 1 0 13.653334-85.333333A85.333333 85.333333 0 0 1 170.666667 533.333333a85.333333 85.333333 0 0 1 85.333333-85.333333 42.666667 42.666667 0 0 0 42.666667-42.666667 213.333333 213.333333 0 0 1 415.146666-68.693333 42.666667 42.666667 0 0 0 33.28 28.586667 128 128 0 0 1 42.666667 235.946666 42.794667 42.794667 0 0 0 42.666667 74.24A213.333333 213.333333 0 0 0 938.666667 490.666667a213.333333 213.333333 0 0 0-152.746667-203.946667z\\\" p-id=\\\"2718\\\"-></path></svg>\"},\"$:/plugins/FSpark/TW5-CSE/ui/cloudlock\":{\"title\":\"$:/plugins/FSpark/TW5-CSE/ui/cloudlock\",\"type\":\"text/vnd.tiddlywiki\",\"text\":\"<svg  class=\\\"tc-image-button\\\" width=\\\"22pt\\\" height=\\\"22pt\\\"  viewBox=\\\"0 0 1024 1024\\\" version=\\\"1.1\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" p-id=\\\"2217\\\"><path d=\\\"M230.793757 841.706296C103.560319 841.706296 0 738.178489 0 610.911817h65.94097c0 90.899399 73.953388 164.852787 164.852787 164.852787v65.941692zM65.94097 610.911817H0c0-96.141789 59.841707-181.140609 148.367725-214.90186v-32.37696c0-154.533458 125.716931-280.250388 280.249666-280.250388 83.152135 0 162.116716 37.553603 215.198803 101.450648 11.077944-1.71447 21.694217-2.539554 32.080016-2.539553 121.46363 0 221.298789 94.296548 230.134846 213.550803 49.191477 18.727672 91.36107 54.105134 117.934987 99.702943l-57.005932 33.201321c-22.023673-37.784077-59.017345-65.743008-101.516395-76.721971l-24.727954-6.39693v-32.541687c0-90.900121-73.953388-164.853509-164.853509-164.853509-11.671109 0-24.100833 1.615488-38.113533 4.946169l-21.661705 5.17592-12.858883-18.167019C562.939903 183.282793 497.658567 149.32358 428.617391 149.32358c-118.166907 0-214.308695 96.141789-214.308696 214.308695v81.964361l-24.727954 6.396929C116.781893 470.786984 65.94097 536.167302 65.94097 610.911817zM230.793757 775.764604h296.73545v65.941692H230.793757zM956.146598 940.617391H626.441024V676.853509h329.706296v263.763882z m-263.764604-65.940971h197.823634v-131.882663H692.381994v131.882663z\\\"- p-id=\\\"2218\\\"></path><path d=\\\"M890.205628 610.911817h-65.940971c0-18.167019-14.771315-32.970846-32.970846-32.970847-18.199532 0-32.970846 14.803827-32.970847 32.970847h-65.941692c0-54.532848 44.378246-98.911817 98.911816-98.911817 54.534293 0 98.912539 44.378969 98.91254 98.911817zM692.381994 610.911817h65.941693v65.941692h-65.941693z\\\"- p-id=\\\"2219\\\"></path><path d=\\\"M824.264657 610.911817h65.940971v65.941692h-65.940971z\\\"- p-id=\\\"2220\\\"></path></svg>\"},\"$:/plugins/FSpark/TW5-CSE/ui/cloudunlock\":{\"title\":\"$:/plugins/FSpark/TW5-CSE/ui/cloudunlock\",\"type\":\"text/vnd.tiddlywiki\",\"text\":\"<svg class=\\\"tc-image-button\\\" width=\\\"22pt\\\" height=\\\"22pt\\\" viewBox=\\\"0 0 1024 1024\\\" version=\\\"1.1\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" p-id=\\\"1753\\\" id=\\\"mx_n_1680423090066\\\"><path d=\\\"M230.793757 841.706296C103.560319 841.706296 0 738.178489 0 610.911817h65.94097c0 90.899399 73.953388 164.852787 164.852787 164.852787v65.941692zM65.94097 610.911817H0c0-96.141789 59.841707-181.140609 148.367725-214.90186v-32.37696c0-154.533458 125.716931-280.250388 280.249666-280.250388 83.152135 0 162.116716 37.553603 215.198803 101.450648 11.077944-1.71447 21.694217-2.539554 32.080016-2.539553 121.46363 0 221.298789 94.296548 230.134846 213.550803 49.191477 18.727672 91.36107 54.105134 117.934987 99.702943l-57.005932 33.201321c-22.023673-37.784077-59.017345-65.743008-101.516395-76.721971l-24.727954-6.39693v-32.541687c0-90.900121-73.953388-164.853509-164.853509-164.853509-11.671109 0-24.100833 1.615488-38.113533 4.946169l-21.661705 5.17592-12.858883-18.167019C562.939903 183.282793 497.658567 149.32358 428.617391 149.32358c-118.166907 0-214.308695 96.141789-214.308696 214.308695v81.964361l-24.727954 6.396929C116.781893 470.786984 65.94097 536.167302 65.94097 610.911817zM230.793757 775.764604h296.73545v65.941692H230.793757zM956.146598 940.617391H626.441024V676.853509h329.706296v263.763882z m-263.764604-65.940971h197.823634v-131.882663H692.381994v131.882663z\\\"- p-id=\\\"1754\\\"></path><path d=\\\"M890.205628 610.911817h-65.940971c0-18.167019-14.771315-32.970846-32.970846-32.970847-18.199532 0-32.970846 14.803827-32.970847 32.970847h-65.941692c0-54.532848 44.378246-98.911817 98.911816-98.911817 54.534293 0 98.912539 44.378969 98.91254 98.911817z\\\"- p-id=\\\"1755\\\"></path><path d=\\\"M692.381994 610.911817h65.941693v65.941692h-65.941693z\\\"- p-id=\\\"1756\\\"></path></svg>\"},\"$:/plugins/FSpark/TW5-CSE/ui/encryption\":{\"title\":\"$:/plugins/FSpark/TW5-CSE/ui/encryption\",\"caption\":\"{{$:/core/images/locked-padlock}} {{$:/language/Buttons/Encryption/Caption}}\",\"description\":\"{{$:/language/Buttons/Encryption/Hint}}\",\"tags\":\"$:/tags/PageControls\",\"type\":\"text/vnd.tiddlywiki\",\"text\":\"\\\\whitespace trim\\n<$reveal type=\\\"match\\\" state=\\\"$:/isCSEncrypted\\\" text=\\\"yes\\\">\\n<$button to=\\\"$:/plugins/FSpark/TW5-CSE/ui/SettingsPanel\\\" tooltip={{$:/language/Buttons/Encryption/ClearPassword/Hint}} aria-label={{$:/language/Buttons/Encryption/ClearPassword/Caption}} class=<<tv-config-toolbar-class>>>\\n<$list filter=\\\"[<tv-config-toolbar-icons>match[yes]]\\\">\\n{{$:/plugins/FSpark/TW5-CSE/ui/cloudlock}}\\n</$list>\\n<$list filter=\\\"[<tv-config-toolbar-text>match[yes]]\\\">\\n<span class=\\\"tc-btn-text\\\">\\n<$text text={{$:/language/Buttons/Encryption/ClearPassword/Caption}}/>\\n</span>\\n</$list>\\n</$button>\\n</$reveal>\\n<$reveal type=\\\"nomatch\\\" state=\\\"$:/isCSEncrypted\\\" text=\\\"yes\\\">\\n<$button message=\\\"tm-cse-set-password\\\" tooltip={{$:/language/Buttons/Encryption/SetPassword/Hint}} aria-label={{$:/language/Buttons/Encryption/SetPassword/Caption}} class=<<tv-config-toolbar-class>>>\\n<$list filter=\\\"[<tv-config-toolbar-icons>match[yes]]\\\">\\n{{$:/plugins/FSpark/TW5-CSE/ui/cloudunlock}}\\n</$list>\\n<$list filter=\\\"[<tv-config-toolbar-text>match[yes]]\\\">\\n<span class=\\\"tc-btn-text\\\">\\n<$text text={{$:/language/Buttons/Encryption/SetPassword/Caption}}/>\\n</span>\\n</$list>\\n</$button>\\n</$reveal>\\n\"},\"$:/plugins/FSpark/TW5-CSE/ui/icon-sync\":{\"title\":\"$:/plugins/FSpark/TW5-CSE/ui/icon-sync\",\"type\":\"text/vnd.tiddlywiki\",\"text\":\"<svg width=\\\"22pt\\\" height=\\\"22pt\\\" class=\\\"tc-image-fa-sync tc-image-button tc-image-cse-cloud-progress\\\" viewBox=\\\"0 0 512 512\\\"><path d=\\\"M440.65 12.57l4 82.77A247.16 247.16 0 0 0 255.83 8C134.73 8 33.91 94.92 12.29 209.82A12 12 0 0 0 24.09 224h49.05a12 12 0 0 0 11.67-9.26 175.91 175.91 0 0 1 317-56.94l-101.46-4.86a12 12 0 0 0-12.57 12v47.41a12 12 0 0 0 12 12H500a12 12 0 0 0 12-12V12a12 12 0 0 0-12-12h-47.37a12 12 0 0 0-11.98 12.57zM255.83 432a175.61 175.61 0 0 1-146-77.8l101.8 4.87a12 12 0 0 0 12.57-12v-47.4a12 12 0 0 0-12-12H12a12 12 0 0 0-12 12V500a12 12 0 0 0 12 12h47.35a12 12 0 0 0 12-12.6l-4.15-82.57A247.17 247.17 0 0 0 255.83 504c121.11 0 221.93-86.92 243.55-201.82a12 12 0 0 0-11.8-14.18h-49.05a12 12 0 0 0-11.67 9.26A175.86 175.86 0 0 1 255.83 432z\\\"/></svg>\"},\"$:/plugins/FSpark/TW5-CSE/ui/PushingModal\":{\"title\":\"$:/plugins/FSpark/TW5-CSE/ui/PushingModal\",\"type\":\"text/vnd.tiddlywiki\",\"footer\":\"\",\"text\":\"@@text-align:center;\\n<div>\\n{{$:/plugins/FSpark/TW5-CSE/ui/icon-sync}}\\n\\n\\n<p>Current progress: synced/total</p>\\n\\n<p>{{$:/temp/CSENumTasksInProgress}}</p>\\n\\n<p>{{$:/temp/CSESyncEstimatedTimeLeft}}</p>\\n\\n</div>\\n@@\\n\\n<$reveal type=\\\"match\\\" state=\\\"$:/state/cse-modal-close\\\" text=\\\"yes\\\">\\n\\n<$macrocall $name=\\\"invoke\\\" action=\\\"\\\"\\\"<$action-sendmessage $message=\\\"tm-close-tiddler\\\"/>\\\"\\\"\\\"/>\\n<$macrocall $name=\\\"invoke\\\" action=\\\"\\\"\\\"<$action-setfield $tiddler=\\\"$:/state/cse-modal-close\\\" text=\\\"no\\\"/>\\\"\\\"\\\"/>\\n\\n</$reveal>\"},\"$:/plugins/FSpark/TW5-CSE/ui/SettingsPanel\":{\"title\":\"$:/plugins/FSpark/TW5-CSE/ui/SettingsPanel\",\"caption\":\"CSEncryption\",\"list\":\"password filter check\",\"tags\":\"$:/tags/ControlPanel\",\"type\":\"text/vnd.tiddlywiki\",\"text\":\"<$tiddler tiddler=\\\"$:/plugins/FSpark/TW5-CSE/ui/SettingsPanel\\\">\\n<<tabs \\\"[enlist{!!list}addprefix[$:/plugins/FSpark/TW5-CSE/settings/]]\\\" \\\"$:/plugins/FSpark/TW5-CSE/settings/password\\\" \\\"\\\" \\\"tc-vertical\\\">>\\n</$tiddler>\"},\"$:/plugins/FSpark/TW5-CSE/ui/styles\":{\"title\":\"$:/plugins/FSpark/TW5-CSE/ui/styles\",\"tags\":\"[[$:/tags/Stylesheet]]\",\"text\":\"\\\\rules only filteredtranscludeinline transcludeinline macrodef macrocallinline macrocallblock\\n\\nbody.tc-dirty .tc-image-cse-cloud-progress {\\n\\ttransition: opacity 250ms ease-in-out;\\n\\ttransform-origin: 50% 50%;\\n\\ttransform: rotate(359deg);\\n\\tanimation: animation-rotate-slow 2s infinite linear;\\n\\tfill: <<colour background>>;\\n}\"}}}"}